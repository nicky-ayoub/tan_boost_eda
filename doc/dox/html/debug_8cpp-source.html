<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>debug.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>debug.cpp</h1><a href="debug_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* Reference : A Handy Debugger Class by Maurice Fox, C/C++ Users Journal Apr 2001</span>
00002 <span class="comment">   Copyright (C) Maurice J. Fox 2000 - 2003</span>
00003 <span class="comment">   Copyright (C) Kwee Heong Tan 2002 - 2003</span>
00004 <span class="comment">   Permission is granted to use this code without restriction as</span>
00005 <span class="comment">   long as this copyright notice appears in all source files.</span>
00006 <span class="comment">*/</span>
00007 <span class="comment">// $Id: Debug.cpp,v 1.16 2002/11/21 17:52:42 khtan Exp khtan $</span>
00008 <span class="preprocessor">#include "Debug.h"</span>
00009 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00010 <span class="comment">// Added enhancements turned on with preprocessor defines</span>
00011 
00012 <span class="preprocessor">#ifdef STL96</span>
00013 <span class="preprocessor"></span><span class="preprocessor">   #define CLEAR(name) name.erase(name.begin(),name.end());</span>
00014 <span class="preprocessor"></span>   <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00015       <span class="keywordtype">int</span> ftime(<span class="keyword">struct</span> timeb *timeptr);
00016    }
00017 <span class="preprocessor">#else</span>
<a name="l00018"></a><a class="code" href="debug_8cpp.html#a0">00018</a> <span class="preprocessor"></span>   <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00019 <span class="preprocessor">   #define CLEAR(name) name.clear()</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#ifdef TESTING</span>
00023 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> f1(<span class="keywordtype">void</span>);
00024 <span class="keyword">static</span> <span class="keywordtype">void</span> f2(<span class="keywordtype">void</span>);
00025 <span class="keywordtype">int</span> <a class="code" href="atpg_8cpp.html#a1">main</a>( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[] ) {
00026     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"main"</span>);
00027     <span class="keywordtype">float</span> pi = (float)3.14;
00028     <span class="keywordtype">int</span>   i = 1999;
00029     <span class="keywordtype">char</span> String[] = <span class="stringliteral">"This is a testing string "</span>;
00030 
00031     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 1; j &lt; argc; j++) {
00032       <a class="code" href="classDebug.html#d0">Debug::specify</a>(argv[j]);
00033       D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"argv[j]"</span>,argv[j]);
00034       D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"float"</span>, pi);
00035       D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"integer"</span>, i);
00036       D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"string"</span>, String, i);
00037       f1();
00038     }
00039     <span class="keywordflow">return</span> 0;
00040 }
00041 
00042 <span class="keyword">static</span> <span class="keywordtype">void</span> f1() {
00043     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"f1"</span>);
00044     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"string"</span>,<span class="stringliteral">"f1's string"</span>);
00045     D.<a class="code" href="classDebug.html#d3">Sync</a>();
00046     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"string"</span>,<span class="stringliteral">"string one "</span>, <span class="stringliteral">"string two"</span>);
00047     f2();
00048 }
00049 
00050 <span class="keyword">static</span> <span class="keywordtype">void</span> f2() {
00051     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"f2"</span>);
00052     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"string"</span>,<span class="stringliteral">"f2's string"</span>);
00053     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"integer"</span>,<span class="stringliteral">"This is an unsigned hex one "</span>, static_cast&lt;unsigned long&gt;(0XDEADBEEF));
00054     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"integer"</span>,<span class="stringliteral">"This is a regular integer "</span>, static_cast&lt;int&gt;(0XDEADBEEF));
00055     <span class="comment">//    D.TimeEnd("bogus,once","This has no preceding TimeStart call");</span>
00056     <span class="comment">//    D.TimeEnd("once","This is in f2");</span>
00057     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"bogus,fred,fork,a,string,integer"</span>,<span class="stringliteral">"a string"</span>);
00058     <a class="code" href="classDebug.html#d3">Debug::Sync</a>();
00059     <span class="comment">//sleep(1);</span>
00060 }
00061 <span class="preprocessor">#endif // TESTING</span>
00062 <span class="preprocessor"></span>
00063 <span class="preprocessor">#ifndef DEBUG_OFF</span>
00064 <span class="preprocessor"></span>    <span class="comment">// Static members</span>
00065 <span class="keywordtype">int</span> Debug::level = 0;
00066 <span class="keywordtype">bool</span> Debug::Debugging = <span class="keyword">false</span>;
00067 <span class="keywordtype">bool</span> Debug::Tracing = <span class="keyword">false</span>;
00068 <span class="keywordtype">bool</span> Debug::Timing = <span class="keyword">false</span>;
00069 STD ofstream* Debug::pFile=NULL;
00070 STD ostream* Debug::pDebugStream=&amp;clog; <span class="comment">// default on startup, use clog</span>
00071 
00072 <span class="keywordtype">char</span> Debug::separator = <span class="charliteral">'?'</span>;
00073 
00074 <span class="keywordtype">char</span> Debug::mybuff[200];
00075 string Debug::filename;
00076 
00077 vector&lt;string&gt; Debug::keywords;
00078 vector&lt;string&gt; Debug::functions;
00079 vector&lt;string&gt; Debug::timekeys;
00080 vector&lt;pair&lt;string, struct timeb&gt; &gt; Debug::timers;
<a name="l00081"></a><a class="code" href="classDebug.html#a0">00081</a> 
00082 <a class="code" href="classDebug.html#a0">Debug::Debug</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* f,<span class="keywordtype">bool</span> rawtimeMode,<span class="keywordtype">bool</span> bEndLine) :
00083 function_name(f), timing(rawtimeMode),raw_time(rawtimeMode),going_in(rawtimeMode)
00084 {
00085     level++;
00086     <span class="keywordflow">if</span>(tracing(function_name)) 
00087         Enter(bEndLine);
00088     going_in=<span class="keyword">false</span>;
<a name="l00089"></a><a class="code" href="classDebug.html#a1">00089</a> }
00090 <a class="code" href="classDebug.html#a1">Debug::~Debug</a>() {
00091         <span class="keywordflow">if</span>(tracing(function_name)) Exit();
00092         level--;
00093 }
00094 
00095 <span class="keywordtype">bool</span> Debug::tracing(<span class="keyword">const</span> string &amp; f) {
00096     <span class="keywordflow">if</span>(!Tracing) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00097     
00098     <span class="keywordflow">return</span> (functions.empty() || 
00099     find(functions.begin(),functions.end(),f) != functions.end());
00100 }
00101 
00102 <span class="keywordtype">bool</span> Debug::debugging(<span class="keyword">const</span> string &amp; k) {
00103     <span class="keywordflow">if</span>(!Debugging) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00104 
00105 <span class="preprocessor">#if defined DEBUG_MULT_KWDS</span>
00106 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( keywords.empty()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00107     string::size_type start, end;
00108     string kw;
00109     start = 0;
00110     <span class="keywordflow">do</span> {<span class="comment">// This is the beginning of a do-while loop</span>
00111         <span class="comment">// Look for a comma delimiting an internal keyword</span>
00112         <span class="comment">// We are assuming well-formed multiple keywords - </span>
00113         <span class="comment">// no leading, trailing, or multiple commas.</span>
00114         end = k.find(<span class="charliteral">','</span>, start);
00115         <span class="keywordflow">if</span>( end == string::npos ) {
00116             <span class="comment">// Assign the rest of k to kw.  This could be all of k</span>
00117             <span class="comment">// when start is still 0.</span>
00118             kw = k.substr(start);
00119         } <span class="keywordflow">else</span> {
00120             <span class="comment">// Assign the substring just found to kw, adjust start point </span>
00121             kw = k.substr(start,end-start);
00122             start = end + 1;
00123         }
00124         <span class="keywordflow">if</span>(find(keywords.begin(),keywords.end(),kw) != keywords.end()) {
00125             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00126         }
00127     } <span class="keywordflow">while</span>( end != string::npos );
00128     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00129 <span class="preprocessor">#else</span>
00130 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (keywords.empty() || 
00131     find(keywords.begin(),keywords.end(),k) != keywords.end());
00132 <span class="preprocessor">#endif</span>
00133 <span class="preprocessor"></span>}
00134 
00135 <span class="keywordtype">bool</span> Debug::IntTiming(<span class="keyword">const</span> string &amp; t) {
00136     <span class="keywordflow">if</span>(!Timing) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00137 
00138 <span class="preprocessor">#if defined DEBUG_MULT_KWDS</span>
00139 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( timekeys.empty()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00140     string::size_type start, end;
00141     string kw;
00142     start = 0;
00143     <span class="keywordflow">do</span> {<span class="comment">// This is the beginning of a do-while loop</span>
00144         <span class="comment">// Look for a comma delimiting an internal keyword</span>
00145         <span class="comment">// We are assuming well-formed multiple keywords - </span>
00146         <span class="comment">// no leading, trailing, or multiple commas.</span>
00147         end = t.find(<span class="charliteral">','</span>, start);
00148         <span class="keywordflow">if</span>( end == string::npos ) {
00149             <span class="comment">// Assign the rest of t to kw.  This could be all of t</span>
00150             <span class="comment">// when start is still 0.</span>
00151             kw = t.substr(start);
00152         } <span class="keywordflow">else</span> {
00153             <span class="comment">// Assign the substring just found to kw, adjust start point </span>
00154             kw = t.substr(start,end-start);
00155             start = end + 1;
00156         }
00157         <span class="keywordflow">if</span>(find(timekeys.begin(),timekeys.end(),kw) != timekeys.end()) {
00158             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00159         }
00160     } <span class="keywordflow">while</span>( end != string::npos );
00161     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00162 <span class="preprocessor">#else</span>
00163 <span class="preprocessor"></span>    <span class="keywordflow">return</span>(timekeys.empty() ||
00164     find(timekeys.begin(),timekeys.end(),t) != timekeys.end());
00165 <span class="preprocessor">#endif</span>
00166 <span class="preprocessor"></span>}
00167 <span class="keywordtype">void</span> Debug::Enter(<span class="keywordtype">bool</span> bEndLine){
00168   string sBuffer;
00169   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; (level &lt; limit ? level : limit) ; i++ ){
00170     sBuffer+=<span class="stringliteral">"  "</span>;
00171   }
00172 <span class="preprocessor">#if defined(EMACS_OUTLINE) // not handling level &gt; limit case</span>
00173 <span class="preprocessor"></span>  sBuffer.replace(0,level-1,level-1,<span class="charliteral">'*'</span>);
00174 <span class="preprocessor">#endif//EMACS_OUTLINE</span>
00175 <span class="preprocessor"></span>
00176   (*pDebugStream) &lt;&lt; sBuffer;
00177   (*pDebugStream) &lt;&lt; <span class="stringliteral">"=&gt; "</span> &lt;&lt; function_name &lt;&lt; time_stuff();
00178   <span class="keywordflow">if</span>(bEndLine) (*pDebugStream) &lt;&lt; <span class="stringliteral">"\n"</span>;
00179 }
00180 <span class="keywordtype">void</span> Debug::Exit(){
00181     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; (level &lt; limit ? level : limit) ; i++ )
00182     (*pDebugStream) &lt;&lt; <span class="stringliteral">"  "</span>;
00183 
00184     (*pDebugStream) &lt;&lt; <span class="stringliteral">"&lt;= "</span> &lt;&lt; function_name &lt;&lt; time_stuff() &lt;&lt; <span class="stringliteral">"\n"</span>;
00185 }
00186 <span class="keywordtype">char</span> * Debug::time_stuff() {
00187     <span class="keywordflow">if</span>(!timing) <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00188 
00189     <span class="keywordflow">if</span>(raw_time) {
00190         <span class="keyword">struct </span>timeb Tb;
00191         ftime(&amp;Tb);
00192         <span class="keywordflow">if</span>(going_in) {
00193             sprintf(mybuff, <span class="stringliteral">" %ld.%03d"</span>,Tb.time, Tb.millitm);
00194             Start = Tb;
00195         } <span class="keywordflow">else</span> {
00196             <span class="keywordtype">long</span> <span class="keywordtype">int</span> secs, millis;
00197             millis = Tb.millitm - Start.millitm;
00198             secs = Tb.time - Start.time;
00199             <span class="keywordflow">if</span>(millis &lt; 0) {
00200                 millis += 1000;
00201                 -- secs;
00202             }
00203             sprintf(mybuff, <span class="stringliteral">"         %ld.%03ld"</span>, secs, millis);
00204         }
00205 
00206     } <span class="keywordflow">else</span> { <span class="comment">// Cooked time</span>
00207         time_t Clock;
00208         time(&amp;Clock);
00209         sprintf(mybuff,<span class="stringliteral">" %s"</span>, asctime(localtime(&amp;Clock)));
00210         mybuff[strlen(mybuff)-1] = <span class="charliteral">'\0'</span>;
00211     }
00212     <span class="keywordflow">return</span> mybuff;
00213 }
00214 
00215 <span class="keywordtype">void</span> Debug::indent() {
00216     <span class="keywordflow">if</span>( Tracing ) {
00217         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= (level &lt; (limit + 1) ? level : (limit + 1)); i++ ) 
00218         (*pDebugStream) &lt;&lt; <span class="stringliteral">"  "</span>;
00219     }
00220 }
00221 <span class="keywordtype">void</span> <a class="code" href="classDebug.html#a2">Debug::Dbg</a>(<span class="keyword">const</span> std::string&amp; keyword, <span class="keyword">const</span> std::string&amp; description, <span class="keywordtype">char</span>* pC){
00222   <span class="comment">// cout &lt;&lt; "-print char*\n";</span>
00223   <span class="keywordflow">if</span>(!debugging(keyword)) <span class="keywordflow">return</span>;
00224   indent();
00225   <span class="keywordflow">if</span>(NULL==pC){
00226     (*pDebugStream) &lt;&lt; keyword &lt;&lt; <span class="stringliteral">": "</span>&lt;&lt; description &lt;&lt; <span class="stringliteral">" = NULL\n"</span>;
00227   }<span class="keywordflow">else</span>{
00228     (*pDebugStream) &lt;&lt; keyword &lt;&lt; <span class="stringliteral">": "</span>&lt;&lt; description &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; pC &lt;&lt; <span class="stringliteral">"\n"</span>;
00229   }
00230 };
00231 <span class="keywordtype">void</span> <a class="code" href="classDebug.html#a2">Debug::Dbg</a>(<span class="keyword">const</span> std::string&amp; keyword, <span class="keywordtype">char</span>* pC){
00232   <span class="comment">// cout &lt;&lt; "-print char*\n";</span>
00233   <span class="keywordflow">if</span>(!debugging(keyword)) <span class="keywordflow">return</span>;
00234   indent();
00235   <span class="keywordflow">if</span>(NULL==pC){
00236     (*pDebugStream) &lt;&lt; keyword &lt;&lt; <span class="stringliteral">": NULL\n"</span>;
00237   }<span class="keywordflow">else</span>{
00238     (*pDebugStream) &lt;&lt; keyword &lt;&lt; <span class="stringliteral">": "</span>&lt;&lt; pC &lt;&lt; <span class="stringliteral">"\n"</span>;
00239   }
00240 };
00241 
00242 <span class="keywordtype">void</span> <a class="code" href="classDebug.html#d1">Debug::TimeStart</a>(<span class="keyword">const</span> string &amp;t, <span class="keyword">const</span> <span class="keywordtype">char</span> *s) {
00243     <span class="keywordflow">if</span>(!IntTiming(t)) <span class="keywordflow">return</span>;
00244     
00245     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00246     <span class="keywordflow">for</span>(i = 0; i &lt; timers.size(); i++) {
00247         <span class="keywordflow">if</span>(timers[i].first == t) <span class="keywordflow">break</span>;
00248     }
00249     timeb tb;
00250     ftime(&amp;tb);
00251     <span class="keywordflow">if</span>( i == timers.size()) {  <span class="comment">// Not found, so put one in.</span>
00252         timers.push_back(make_pair(t,tb));
00253     } <span class="keywordflow">else</span> {
00254         timers[i].second = tb;
00255     }
00256     sprintf(mybuff,<span class="stringliteral">" %ld.%03d"</span>, tb.time, tb.millitm);
00257 
00258     indent();
00259     (*pDebugStream) &lt;&lt; t &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; s &lt;&lt; mybuff &lt;&lt; <span class="stringliteral">"\n"</span>;
00260 }
00261     
00262 <span class="keywordtype">void</span> <a class="code" href="classDebug.html#d2">Debug::TimeEnd</a>(<span class="keyword">const</span> string &amp;t, <span class="keyword">const</span> <span class="keywordtype">char</span> *s) {
00263     <span class="keywordflow">if</span>(!IntTiming(t)) <span class="keywordflow">return</span>;
00264     
00265     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00266     <span class="keywordflow">for</span>(i = 0; i &lt; timers.size(); i++) {
00267         <span class="keywordflow">if</span>(timers[i].first == t) <span class="keywordflow">break</span>;
00268     }
00269     timeb tb;
00270     ftime(&amp;tb);
00271     <span class="keywordflow">if</span>( i == timers.size()) { <span class="comment">// Not found!</span>
00272         <span class="comment">// This puts an entry in the timers vector</span>
00273         <span class="comment">// it won't be very informative, but it keeps</span>
00274         <span class="comment">// things going OK.</span>
00275         timers.push_back(make_pair(t,tb));
00276     }
00277     <span class="comment">// i now has the index of our timer in the vector</span>
00278 
00279     <span class="keywordtype">int</span> secs, millis;
00280     millis = tb.millitm - timers[i].second.millitm;
00281     secs = tb.time - timers[i].second.time;
00282     <span class="keywordflow">if</span>(millis &lt; 0) {
00283         millis += 1000;
00284         --secs;
00285     }
00286     sprintf(mybuff, <span class="stringliteral">" %d.%03d"</span>, secs, millis);
00287 
00288     indent();
00289     (*pDebugStream) &lt;&lt; t &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; s &lt;&lt; mybuff &lt;&lt; <span class="stringliteral">"\n"</span>;
00290 }
<a name="l00291"></a><a class="code" href="classDebug.html#d3">00291</a> 
00292 <span class="keywordtype">void</span> <a class="code" href="classDebug.html#d3">Debug::Sync</a>() {
00293     pDebugStream-&gt;flush();
00294 }
00295     
00296 <span class="comment">/***********************************</span>
00297 <span class="comment">* Debug::specify()</span>
00298 <span class="comment">* Extracts options and keywords from a Debug specification string</span>
00299 <span class="comment">* and deals with them "appropriately."</span>
00300 <span class="comment">* </span>
00301 <span class="comment">* PSEUDOCODE:</span>
00302 <span class="comment">* look for an option</span>
00303 <span class="comment">* while(there is an option)</span>
00304 <span class="comment">*   look for next option or end of string</span>
00305 <span class="comment">*   look for a keyword in the substring thus found</span>
00306 <span class="comment">*   while(where is a keyword)</span>
00307 <span class="comment">*       depending upon the option found</span>
00308 <span class="comment">*       save the keyword OR</span>
00309 <span class="comment">*       extract and save some value OR</span>
00310 <span class="comment">*       ignore the keyword</span>
00311 <span class="comment">*       look for a keyword</span>
00312 <span class="comment">*   end while</span>
00313 <span class="comment">* end while</span>
00314 <span class="comment">*</span>
00315 <span class="comment">* Option strings have the form</span>
00316 <span class="comment">* L:keyword,keyword,L:keyword,keyword,</span>
00317 <span class="comment">* L:L:keyword,keyword</span>
00318 <span class="comment">* L:L:,keyword</span>
00319 <span class="comment">* etc.  Terminating commas are optional</span>
00320 <span class="comment">* Leading commas are harmless.</span>
<a name="l00321"></a><a class="code" href="classDebug.html#d0">00321</a> <span class="comment">**************************************/</span>
00322 <span class="keywordtype">void</span> <a class="code" href="classDebug.html#d0">Debug::specify</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * opt) {
00323   string s = opt;
00324 
00325   <span class="comment">// Find options</span>
00326   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = s.find_first_of(separator,0);
00327   <span class="keywordflow">while</span>(j &lt; s.length()) {  <span class="comment">// Option found</span>
00328     <span class="comment">// j points to the separator at the end of this option</span>
00329 
00330     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = s.find_first_of(separator,j+1);
00331     <span class="comment">// k now points to the separator at the end of the next option</span>
00332     <span class="comment">// or to outer space</span>
00333         
00334     string Option;
00335     <span class="keywordflow">if</span>(j == 0) {
00336       Option = <span class="stringliteral">"0"</span>;
00337       Option += s[0];
00338     } <span class="keywordflow">else</span> {
00339       Option = string(s,j-1,2);
00340     }
00341         
00342     <span class="comment">// Find keywords</span>
00343     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = s.find_first_of(<span class="charliteral">','</span>,j+1);
00344 
00345     <span class="comment">// Deal with the case of no comma, like F:keywordD: or</span>
00346     <span class="comment">// F:keyword</span>
00347     <span class="keywordflow">if</span>((l &gt;= k) &amp;&amp; (j &lt; k-2)) {
00348       <span class="keywordflow">if</span>( k &gt; s.length() ) <span class="comment">// No trailing option</span>
00349         l = s.length();
00350       <span class="keywordflow">else</span> l = k-1;    <span class="comment">// Trailing option is found</span>
00351     }
00352     <span class="keywordflow">while</span>(l &lt; k) {  <span class="comment">// keyword found</span>
00353       string kw;
00354       <span class="keywordflow">if</span>(j+1 &lt; l ) {
00355         kw = string(s,j+1,l-j-1);
00356       } <span class="keywordflow">else</span> {
00357         kw = <span class="stringliteral">""</span>;
00358       }
00359 
00360       <span class="keywordflow">if</span>( l &lt; s.length() ) {
00361             
00362         j = l;  <span class="comment">// Advance to virtual ( or real ) comma.</span>
00363         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = s.find_first_of(<span class="charliteral">','</span>,l+1);
00364 
00365         <span class="comment">// Again, what if there's no trailing comma in a</span>
00366         <span class="comment">// sequence of keywords like F:abcd,efgh,ijklD:</span>
00367         <span class="comment">// or F:a,b,c,d</span>
00368         <span class="keywordflow">if</span>((m &gt;= k) &amp;&amp; (j &lt; k-1)) {
00369           <span class="keywordflow">if</span>( (m &gt; s.length()) &amp;&amp; ( k &gt; s.length()))
00370             m = s.length();
00371           <span class="keywordflow">else</span> m = k-1;
00372         }
00373         l = m;
00374       } <span class="keywordflow">else</span> l = k;  <span class="comment">// Bail out of the loop</span>
00375 
00376       <span class="comment">// This is where we deal with the keywords and options</span>
00377       <span class="keywordflow">switch</span>(Option[0]) {
00378       <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:    <span class="comment">// Turn debugging on</span>
00379         <span class="keywordflow">if</span>(kw.length()) keywords.push_back(kw);
00380         <span class="keywordflow">break</span>;
00381 
00382       <span class="keywordflow">case</span> <span class="charliteral">'O'</span>:   <span class="comment">// Changing output, maybe</span>
00383 <span class="preprocessor">#ifdef STL96</span>
00384 <span class="preprocessor"></span>          <span class="keywordflow">if</span>(!( (! kw.length()) || kw==filename)) {
00385 <span class="preprocessor">#else</span>
00386 <span class="preprocessor"></span>          <span class="keywordflow">if</span>(kw.length() &amp;&amp; kw != filename) {
00387 <span class="preprocessor">#endif</span>
00388 <span class="preprocessor"></span>            filename = kw;
00389             <span class="keywordflow">if</span>( kw == <span class="stringliteral">"-"</span>){
00390               pDebugStream=&amp;cout;
00391             }<span class="keywordflow">else</span>{ 
00392               <span class="keywordflow">if</span>(kw == <span class="stringliteral">"--"</span>) {
00393                 pDebugStream=&amp;clog;
00394               }<span class="keywordflow">else</span>{
00395                 <span class="keywordflow">if</span>(NULL!=pFile){
00396                   <span class="keyword">delete</span> pFile;
00397                   pFile=NULL;
00398                 }
00399                 pFile=<span class="keyword">new</span>(ofstream);
00400                 pFile-&gt;open(filename.c_str(),ios::app);
00401                 pDebugStream=pFile;
00402               }
00403             }
00404           }
00405           <span class="keywordflow">break</span>;
00406 
00407         <span class="keywordflow">case</span> <span class="charliteral">'T'</span>:    <span class="comment">// Turn tracing on</span>
00408           <span class="keywordflow">if</span>(kw.length()) functions.push_back(kw);
00409           <span class="keywordflow">break</span>;
00410 
00411         <span class="keywordflow">case</span> <span class="charliteral">'M'</span>:    <span class="comment">// Turn interval timing on</span>
00412           <span class="keywordflow">if</span>(kw.length()) timekeys.push_back(kw);
00413           <span class="keywordflow">break</span>;
00414 
00415         <span class="keywordflow">default</span>:       <span class="comment">// Ignore other options silently</span>
00416           <span class="keywordflow">break</span>;
00417         }
00418       } <span class="comment">// end of loop on finding keywords</span>
00419       <span class="comment">// This is where we complete dealing with options</span>
00420       <span class="keywordflow">switch</span>(Option[0]) {
00421       <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:    <span class="comment">// Turn debugging on</span>
00422         Debugging = <span class="keyword">true</span>;
00423         <span class="keywordflow">break</span>;
00424 
00425       <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:       <span class="comment">// Turn debugging off</span>
00426         <a class="code" href="debug_8cpp.html#a0">CLEAR</a>(keywords);
00427         Debugging = <span class="keyword">false</span>;
00428         <span class="keywordflow">break</span>;
00429 
00430       <span class="keywordflow">case</span> <span class="charliteral">'O'</span>:   <span class="comment">// Changing output, maybe - khtan : no longer needed</span>
00431         <span class="keywordflow">break</span>;
00432 
00433       <span class="keywordflow">case</span> <span class="charliteral">'T'</span>:    <span class="comment">// Turn tracing on</span>
00434         Tracing = <span class="keyword">true</span>;
00435         <span class="keywordflow">break</span>;
00436 
00437       <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:       <span class="comment">// Turn tracing off</span>
00438             <a class="code" href="debug_8cpp.html#a0">CLEAR</a>(functions);
00439         Tracing = <span class="keyword">false</span>;
00440         <span class="keywordflow">break</span>;
00441             
00442       <span class="keywordflow">case</span> <span class="charliteral">'M'</span>:       <span class="comment">// Turn interval timing on</span>
00443         Timing = <span class="keyword">true</span>;
00444         <span class="keywordflow">break</span>;
00445 
00446       <span class="keywordflow">case</span> <span class="charliteral">'m'</span>:       <span class="comment">// Turn interval timing off</span>
00447             <a class="code" href="debug_8cpp.html#a0">CLEAR</a>(timekeys);
00448         <a class="code" href="debug_8cpp.html#a0">CLEAR</a>(timers);
00449         Timing = <span class="keyword">false</span>;
00450         <span class="keywordflow">break</span>;
00451 
00452       <span class="keywordflow">default</span>:       <span class="comment">// Ignore other options silently</span>
00453         <span class="keywordflow">break</span>;
00454       }
00455       j = k; <span class="comment">// Advance to next option</span>
00456     } <span class="comment">// end of loop on finding options</span>
00457 }
00458 <span class="preprocessor">#endif // ndef DEBUG_OFF</span>
</pre></div><hr><address style="align: right;"><small>Generated on Mon Jan 20 11:54:25 2003 for ATPG by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
