<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>atpg.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>atpg.hpp</h1><a href="atpg_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* Copyright (C) Kwee Heong Tan 2002 - 2003</span>
00002 <span class="comment">   Permission is granted to use this code without restriction as</span>
00003 <span class="comment">   long as this copyright notice appears in all source files.</span>
00004 <span class="comment">*/</span>
00005 <span class="comment">// $Id$</span>
00006 <span class="comment">// standard inclusions</span>
00007 <span class="preprocessor">#include &lt;boost/config.hpp&gt;</span>
00008 <span class="preprocessor">#include &lt;functional&gt;</span>
00009 <span class="preprocessor">#include &lt;numeric&gt;</span>
00010 <span class="preprocessor">#include &lt;iostream&gt;</span>
00011 <span class="preprocessor">#include &lt;fstream&gt;</span>
00012 <span class="preprocessor">#include &lt;sstream&gt;</span>
00013 <span class="preprocessor">#include &lt;string&gt;</span>
00014 <span class="preprocessor">#include &lt;vector&gt;</span>
00015 <span class="preprocessor">#include &lt;set&gt;</span>
00016 <span class="preprocessor">#include &lt;deque&gt;</span>
00017 <span class="comment">// boost inclusions, except config.hpp</span>
00018 <span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>
00019 <span class="preprocessor">#include &lt;boost/type_traits.hpp&gt;</span>
00020 <span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span>
00021 <span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span>
00022 <span class="preprocessor">#include &lt;boost/pending/queue.hpp&gt;</span>
00023 <span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span>
00024 <span class="preprocessor">#include &lt;boost/graph/graph_utility.hpp&gt;</span>
00025 <span class="preprocessor">#include &lt;boost/graph/graph_traits.hpp&gt;</span>
00026 <span class="preprocessor">#include &lt;boost/graph/properties.hpp&gt;</span>
00027 <span class="preprocessor">#include &lt;boost/graph/depth_first_search.hpp&gt;</span>
00028 <span class="preprocessor">#include &lt;boost/graph/breadth_first_search.hpp&gt;</span>
00029 <span class="preprocessor">#include &lt;boost/graph/graphviz.hpp&gt;</span>
00030 <span class="preprocessor">#include &lt;boost/graph/reverse_graph.hpp&gt;</span>
00031 <span class="comment">// local inclusions</span>
00032 <span class="preprocessor">#include "Debug.hpp"</span>
00033 <span class="preprocessor">#include "<a class="code" href="DFrontier_8hpp.html">DFrontier.hpp</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="DLogic_8hpp.html">DLogic.hpp</a>"</span>
00035 <span class="comment">// std namespace usage</span>
00036 <span class="keyword">using</span> std::accumulate;
00037 <span class="keyword">using</span> std::find_if;
00038 <span class="keyword">using</span> std::for_each;
00039 <span class="keyword">using</span> std::transform;
00040 <span class="keyword">using</span> std::copy;
00041 <span class="keyword">using</span> std::back_inserter;
00042 <span class="keyword">using</span> std::unary_function;
00043 <span class="keyword">using</span> std::binary_function;
00044 <span class="keyword">using</span> std::bind2nd;
00045 <span class="keyword">using</span> std::cout;
00046 <span class="keyword">using</span> std::ostream_iterator;
00047 <span class="keyword">using</span> std::ostringstream;
00048 <span class="keyword">using</span> std::ifstream;
00049 <span class="keyword">using</span> std::ios;
00050 <span class="keyword">using</span> std::string;
00051 <span class="keyword">using</span> std::vector;
00052 <span class="keyword">using</span> std::set;
00053 <span class="keyword">using</span> std::deque;
00054 <span class="keyword">using</span> std::logical_and;
00055 <span class="keyword">using</span> std::logical_or;
00056 <span class="keyword">using</span> std::boolalpha;
00057 <span class="comment">// boost namespace usage</span>
00058 <span class="keyword">using</span> boost::tuple;
00059 <span class="keyword">using</span> boost::queue;
00060 <span class="keyword">using</span> boost::white_color;
00061 <span class="keyword">using</span> boost::gray_color;
00062 <span class="keyword">using</span> boost::black_color;
00063 <span class="keyword">using</span> boost::lexical_cast;
00064 <span class="keyword">using</span> boost::tie;
00065 <span class="keyword">using</span> boost::adjacency_list;
00066 <span class="keyword">using</span> boost::listS;
00067 <span class="keyword">using</span> boost::vecS;
00068 <span class="keyword">using</span> boost::directedS;
00069 <span class="keyword">using</span> boost::property;
00070 <span class="keyword">using</span> boost::is_same;
00071 <span class="keyword">using</span> boost::graph_traits;
00072 <span class="keyword">using</span> boost::property_map;
00073 <span class="keyword">using</span> boost::default_dfs_visitor;
00074 <span class="keyword">using</span> boost::default_bfs_visitor;
00075 <span class="keyword">using</span> boost::visitor;
00076 <span class="keyword">using</span> boost::depth_first_search;
00077 <span class="keyword">using</span> boost::depth_first_visit;
00078 <span class="keyword">using</span> boost::breadth_first_search;
00079 <span class="keyword">using</span> boost::breadth_first_visit;
00080 <span class="keyword">using</span> boost::GraphvizGraph;
00081 <span class="keyword">using</span> boost::GraphvizDigraph;
00082 <span class="keyword">using</span> boost::read_graphviz;
00083 <span class="keyword">using</span> boost::write_graphviz;
00084 <span class="keyword">using</span> boost::num_vertices;
00085 <span class="keyword">using</span> boost::make_iterator_property_map;
00086 <span class="keyword">using</span> boost::vertex_index_t;
00087 <span class="keyword">using</span> boost::vertex_index;
00088 <span class="keyword">using</span> boost::get;
00089 <span class="keyword">using</span> boost::vertex_name_t;
00090 <span class="keyword">using</span> boost::vertex_name;
00091 <span class="keyword">using</span> boost::edge_weight_t;
00092 <span class="keyword">using</span> boost::edge_weight;
00093 <span class="keyword">using</span> boost::vertex_attribute_t;
00094 <span class="keyword">using</span> boost::vertex_attribute;
00095 <span class="keyword">using</span> boost::edge_attribute_t;
00096 <span class="keyword">using</span> boost::edge_attribute;
00097 <span class="keyword">using</span> boost::vertex_color_t;
00098 <span class="keyword">using</span> boost::vertex_color;
00099 <span class="keyword">using</span> boost::default_color_type;
00100 <span class="keyword">using</span> boost::vertices;
00101 <span class="keyword">using</span> boost::adjacent_vertices;
00102 <span class="keyword">using</span> boost::edges;
00103 <span class="keyword">using</span> boost::in_edges;
00104 <span class="keyword">using</span> boost::out_edges;
00105 <span class="keyword">using</span> boost::in_degree;
00106 <span class="keyword">using</span> boost::out_degree;
00107 <span class="keyword">using</span> boost::degree;
00108 <span class="keyword">using</span> boost::source;
00109 <span class="keyword">using</span> boost::target;
00110 <span class="keyword">using</span> boost::reverse_graph;
00111 <span class="comment">// extended BGL functionality</span>
00112 <span class="keyword">using</span> boost::dfv;
00113 <span class="keyword">using</span> boost::dfs;
00114 
00129 <span class="comment">// ------------------------------------------------------------</span>
00130 <span class="comment">// Problem areas</span>
00131 <span class="comment">// ------------------------------------------------------------</span>
00132 
00133 <span class="comment">// ------------------------------------------------------------</span>
00134 <span class="comment">// Global Typedefs</span>
<a name="l00135"></a><a class="code" href="atpg_8hpp.html#a0">00135</a> <span class="comment">// ------------------------------------------------------------</span>
00136 <span class="keyword">typedef</span> tuple&lt;bool,bool,bool&gt; <a class="code" href="atpg_8hpp.html#a0">tripleBool</a>;
00137 
00138 <span class="comment">// ------------------------------------------------------------</span>
00139 <span class="comment">// class SupportGraph</span>
<a name="l00140"></a><a class="code" href="classSupportGraph.html">00140</a> <span class="comment">// ------------------------------------------------------------</span>
00141 <span class="keyword">class </span><a class="code" href="classSupportGraph.html">SupportGraph</a>{
00142 <span class="comment">/* Utility class to hold special functions.</span>
00143 <span class="comment">   - check whether a .dot file is a graph or digraph.</span>
00144 <span class="comment"> */</span>
<a name="l00145"></a><a class="code" href="classSupportGraph.html#s4">00145</a> <span class="keyword">public</span>:
00146       <span class="keyword">enum</span> <a class="code" href="classSupportGraph.html#s4">DotFileType</a>{<a class="code" href="classSupportGraph.html#s4s0">Unknown</a>,<a class="code" href="classSupportGraph.html#s4s1">Digraph</a>,<a class="code" href="classSupportGraph.html#s4s2">Graph</a>,<a class="code" href="classSupportGraph.html#s4s3">N</a>};
00147       <span class="keyword">static</span> <a class="code" href="classSupportGraph.html#s4">DotFileType</a> <a class="code" href="classSupportGraph.html#d0">getDotFileType</a>(<span class="keyword">const</span> string&amp; path);
<a name="l00148"></a><a class="code" href="classSupportGraph.html#a0">00148</a>       <span class="keyword">static</span> <span class="keywordtype">char</span>* <a class="code" href="classSupportGraph.html#p0">_DotFileStringType</a>[<a class="code" href="classSupportGraph.html#s4s3">N</a>];
00149       <a class="code" href="classSupportGraph.html#a0">SupportGraph</a>(){};
00150 <span class="keyword">private</span>:
00151       <a class="code" href="classSupportGraph.html#a0">SupportGraph</a>(<span class="keyword">const</span> <a class="code" href="classSupportGraph.html">SupportGraph</a>&amp;);
00152       <a class="code" href="classSupportGraph.html">SupportGraph</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classSupportGraph.html">SupportGraph</a>&amp;);
<a name="l00153"></a><a class="code" href="classSupportGraph.html#p0">00153</a> };
00154 <span class="keywordtype">char</span>* <a class="code" href="classSupportGraph.html#p0">SupportGraph::_DotFileStringType</a>[N]={<span class="stringliteral">"Unknown"</span>,<span class="stringliteral">"Digraph"</span>,<span class="stringliteral">"Graph"</span>};
<a name="l00155"></a><a class="code" href="classSupportGraph.html#d0">00155</a> 
00156 <a class="code" href="classSupportGraph.html#s4">SupportGraph::DotFileType</a> <a class="code" href="classSupportGraph.html#d0">SupportGraph::getDotFileType</a>(<span class="keyword">const</span> string&amp; path){
00157   <span class="comment">/* Can't inquire about a Graphviz's type until we read it in, and</span>
00158 <span class="comment">     can read the graph in until we declare its type.</span>
00159 <span class="comment">     So read the .dot file and see what's in the first line</span>
00160 <span class="comment">   */</span>
00161   ifstream inDotFile(path.c_str(),ios::in);
00162   string tokenRead;
00163   <span class="keywordflow">while</span>(inDotFile&gt;&gt;tokenRead){ <span class="comment">// read first line only</span>
00164     <span class="comment">// cout &lt;&lt; "tokenRead==" &lt;&lt; tokenRead &lt;&lt; "\n";</span>
00165     inDotFile.close();
00166     <span class="keywordflow">if</span>(string::npos!=tokenRead.find(<span class="stringliteral">"digraph"</span>)){
00167       <span class="keywordflow">return</span> <a class="code" href="classSupportGraph.html#s4s1">Digraph</a>;
00168     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(string::npos!=tokenRead.find(<span class="stringliteral">"graph"</span>)){
00169       <span class="keywordflow">return</span> <a class="code" href="classSupportGraph.html#s4s2">Graph</a>;
00170     }<span class="keywordflow">else</span>{
00171       <span class="keywordflow">return</span> <a class="code" href="classSupportGraph.html#s4s0">Unknown</a>;
00172     }
00173   }
00174   <span class="keywordflow">return</span> <a class="code" href="classSupportGraph.html#s4s0">Unknown</a>;
00175 };
00176 <span class="comment">// ------------------------------------------------------------</span>
00177 <span class="comment">// class VertexSignalPair</span>
00178 <span class="comment">// ------------------------------------------------------------</span>
<a name="l00179"></a><a class="code" href="classVertexSignalPair.html">00179</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> VertexType&gt;
00180 <span class="keyword">class </span><a class="code" href="classVertexSignalPair.html">VertexSignalPair</a>{
00181 <span class="comment">/* Class to hold a vertex and a suggested DLogic signal to apply to it.</span>
00182 <span class="comment">   By defining operator&lt; only in terms of the Vertex, we can easily</span>
00183 <span class="comment">   create sets that are vertex-unique.</span>
00184 <span class="comment">   NB - compiler defaults of destructor, copy constructor, operator= sufficient</span>
00185 <span class="comment"> */</span>
<a name="l00186"></a><a class="code" href="classVertexSignalPair.html#a0">00186</a> <span class="keyword">public</span>:
<a name="l00187"></a><a class="code" href="classVertexSignalPair.html#a1">00187</a>   <a class="code" href="classVertexSignalPair.html#a0">VertexSignalPair</a>(VertexType v,<a class="code" href="classDLogic.html">DLogic</a> s) : _v(v), _s(s) {};
<a name="l00188"></a><a class="code" href="classVertexSignalPair.html#a2">00188</a>   VertexType <a class="code" href="classVertexSignalPair.html#a1">getVertex</a>() { <span class="keywordflow">return</span> _v; }
<a name="l00189"></a><a class="code" href="classVertexSignalPair.html#a3">00189</a>   VertexType <a class="code" href="classVertexSignalPair.html#a1">getVertex</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _v; }
<a name="l00190"></a><a class="code" href="classVertexSignalPair.html#a4">00190</a>   <a class="code" href="classDLogic.html">DLogic</a> <a class="code" href="classVertexSignalPair.html#a3">getSignal</a>() { <span class="keywordflow">return</span> _s; }
<a name="l00191"></a><a class="code" href="classVertexSignalPair.html#a5">00191</a>   <a class="code" href="classDLogic.html">DLogic</a> <a class="code" href="classVertexSignalPair.html#a3">getSignal</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _s; }
00192   <span class="keywordtype">bool</span> operator&lt;(const VertexSignalPair&lt;VertexType&gt;&amp; rhs) <span class="keyword">const</span>{
00193     <span class="keywordflow">return</span> (this-&gt;<a class="code" href="classVertexSignalPair.html#a1">getVertex</a>() &lt; rhs.getVertex());
<a name="l00194"></a><a class="code" href="classVertexSignalPair.html#l0">00194</a>   }
00195   <span class="keyword">friend</span> ostream&amp; operator&lt;&lt;(ostream&amp; ostr,const VertexSignalPair&lt;VertexType&gt;&amp; objref){
00196     ostr &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; objref.getVertex() &lt;&lt; <span class="stringliteral">":"</span>&lt;&lt; objref.getSignal() &lt;&lt; <span class="stringliteral">")"</span>;
00197     <span class="keywordflow">return</span> ostr;
00198   };
00199 <span class="keyword">private</span>:
00200   <a class="code" href="classVertexSignalPair.html#a0">VertexSignalPair</a>(){};
00201   VertexType _v;
00202   <a class="code" href="classDLogic.html">DLogic</a> _s;
00203 };
00204 <span class="comment">// ------------------------------------------------------------</span>
00205 <span class="comment">// function dumpDFrontier</span>
00206 <span class="comment">// function dumpSetVS</span>
00207 <span class="comment">// function putDescendantsInDFrontier</span>
00208 <span class="comment">// function putDescendantsInPContainer</span>
00209 <span class="comment">// ------------------------------------------------------------</span>
<a name="l00210"></a><a class="code" href="atpg_8hpp.html#a1">00210</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> VertexType,<span class="keyword">class</span> VertexAttrMapType&gt;
00211 <span class="keywordtype">void</span> <a class="code" href="atpg_8hpp.html#a1">dumpDFrontier</a>(std::deque&lt;VertexType&gt;&amp; dF,VertexAttrMapType&amp; vMap){
00212   <span class="keyword">typedef</span> std::deque&lt;VertexType&gt; DFrontierType;
00213   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"dumpDFrontier"</span>);
00214   ostringstream outputString;
00215   <span class="keywordflow">if</span>(0==dF.size()){
00216     outputString &lt;&lt; <span class="stringliteral">"empty"</span>;
00217   }<span class="keywordflow">else</span>{
00218     <span class="keywordflow">for</span>(DFrontierType::iterator iD=dF.begin();iD!=dF.end();++iD){
00219       outputString &lt;&lt; vMap[*iD][<span class="stringliteral">"label"</span>]+<span class="stringliteral">","</span>;
00220     }
00221   }
00222   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"DFrontier=="</span>,outputString.str());
00223 };
<a name="l00224"></a><a class="code" href="atpg_8hpp.html#a2">00224</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> VertexType,<span class="keyword">class</span> VertexAttrMapType&gt;
00225 <span class="keywordtype">void</span> <a class="code" href="atpg_8hpp.html#a2">dumpSetVS</a>(std::set&lt;<a class="code" href="classVertexSignalPair.html">VertexSignalPair&lt;VertexType&gt;</a> &gt; &amp; sVS,VertexAttrMapType&amp; vMap){
00226   <span class="keyword">typedef</span> set&lt;VertexSignalPair&lt;VertexType&gt; &gt; SetVertexSignalPairType;
00227   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"dumpSetVS"</span>);
00228   ostringstream outputString;
00229   <span class="keywordflow">if</span>(0==sVS.size()){
00230     outputString &lt;&lt; <span class="stringliteral">"empty"</span>;
00231   }<span class="keywordflow">else</span>{
00232     <span class="keywordflow">for</span>(SetVertexSignalPairType::iterator iD=sVS.begin();iD!=sVS.end();++iD){
00233       outputString &lt;&lt; vMap[iD-&gt;getVertex()][<span class="stringliteral">"label"</span>]+<span class="stringliteral">"+"</span>;
00234       outputString &lt;&lt; iD-&gt;getSignal();
00235       outputString &lt;&lt; <span class="stringliteral">","</span>;
00236     }
00237   }
00238   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"sVS=="</span>,outputString.str());
00239 };
<a name="l00240"></a><a class="code" href="atpg_8hpp.html#a3">00240</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> VertexType, <span class="keyword">class</span> GraphType&gt; 
00241 <span class="keywordtype">void</span> <a class="code" href="atpg_8hpp.html#a3">putDescendantsInDFrontier</a>(VertexType&amp; v,GraphType&amp; g,std::deque&lt;VertexType&gt;&amp; dF){
00242   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::vertex_attribute_t&gt;::type VertexAttrMapType;
00243   <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::adjacency_iterator AdjacencyIteratorType;
00244   <span class="keyword">typedef</span> std::deque&lt;VertexType&gt; DFrontierType;
00245     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"putDescendantsInDFrontier"</span>);
00246     VertexAttrMapType vMap=boost::get(boost::vertex_attribute,g);
00247     AdjacencyIteratorType startAI, endAI;
00248     <span class="keywordflow">for</span>(tie(startAI,endAI)=adjacent_vertices(v,g);startAI!=endAI;++startAI){
00249       DFrontierType::iterator iVertexFound=std::find(dF.begin(),dF.end(),*startAI);
00250       <span class="keywordflow">if</span>(dF.end()==iVertexFound){
00251         dF.push_back(*startAI);
00252       }<span class="comment">//if *startAI not already in DFrontier</span>
00253     }<span class="comment">//for adjacent_vertices</span>
00254     <a class="code" href="atpg_8hpp.html#a1">dumpDFrontier</a>(dF,vMap);
00255 };
<a name="l00256"></a><a class="code" href="atpg_8hpp.html#a4">00256</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> VertexType, <span class="keyword">class</span> GraphType&gt; 
00257 <span class="keywordtype">void</span> <a class="code" href="atpg_8hpp.html#a4">putDescendantsInPContainer</a>(VertexType&amp; v,GraphType&amp; g,std::deque&lt;VertexType&gt;&amp; cV){
00258   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::vertex_attribute_t&gt;::type VertexAttrMapType;
00259   <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::adjacency_iterator AdjacencyIteratorType;
00260     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"putDescendantsInPContainer"</span>);
00261     VertexAttrMapType vMap=boost::get(vertex_attribute,g);
00262     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"source vertex=="</span>,vMap[v][<span class="stringliteral">"label"</span>]);
00263     AdjacencyIteratorType startAI, endAI;
00264     <span class="keywordflow">for</span>(tie(startAI,endAI)=adjacent_vertices(v,g);startAI!=endAI;++startAI){
00265         D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"descendant vertex =="</span>,vMap[*startAI][<span class="stringliteral">"label"</span>]);
00266         cV.push_back(*startAI);
00267     }<span class="comment">//for adjacent_vertices</span>
00268 };
00269 <span class="comment">// ------------------------------------------------------------</span>
00270 <span class="comment">// struct isDTypeFunctor</span>
00271 <span class="comment">// struct isXTypeFunctor</span>
00272 <span class="comment">// function DPassable</span>
00273 <span class="comment">// function OutputConsistent</span>
00274 <span class="comment">// function EvaluateOutputs</span>
00275 <span class="comment">// function EvaluateSingleInput</span>
00276 <span class="comment">// function EvaluateMultipleInputs</span>
00277 <span class="comment">// function setOutputEdges</span>
<a name="l00278"></a><a class="code" href="structisDTypeFunctor.html">00278</a> <span class="comment">// ------------------------------------------------------------</span>
<a name="l00279"></a><a class="code" href="structisDTypeFunctor.html#a0">00279</a> <span class="keyword">struct </span><a class="code" href="structisDTypeFunctor.html">isDTypeFunctor</a>{
00280   <span class="keywordtype">bool</span> <a class="code" href="structisDTypeFunctor.html#a0">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDLogic.html">DLogic</a>&amp; lhs)<span class="keyword"> const</span>{
00281     <span class="keywordflow">return</span> (<a class="code" href="classDLogic.html#p2">DLogic::D</a>==lhs || <a class="code" href="classDLogic.html#p3">DLogic::_D</a>==lhs);
00282   }
<a name="l00283"></a><a class="code" href="structisXTypeFunctor.html">00283</a> };
<a name="l00284"></a><a class="code" href="structisXTypeFunctor.html#a0">00284</a> <span class="keyword">struct </span><a class="code" href="structisXTypeFunctor.html">isXTypeFunctor</a>{
00285   <span class="keywordtype">bool</span> <a class="code" href="structisXTypeFunctor.html#a0">operator()</a>(<span class="keyword">const</span> <a class="code" href="classDLogic.html">DLogic</a>&amp; lhs)<span class="keyword"> const</span>{
00286     <span class="keywordflow">return</span> (<a class="code" href="classDLogic.html#p4">DLogic::X</a>==lhs);
00287   }
00288 };
<a name="l00289"></a><a class="code" href="atpg_8hpp.html#a5">00289</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ContainerType&gt;
00290 <span class="keywordtype">bool</span> <a class="code" href="atpg_8hpp.html#a5">DPassable</a>(ContainerType&amp; vDLogic, <a class="code" href="classDLogic.html">DLogic</a> result){
00291 <span class="comment">/* Verifies that if D/_D is in the input set, the result</span>
00292 <span class="comment">   contains a D/_D.</span>
00293 <span class="comment"></span>
00294 <span class="comment">   This is used to indicate whether the D/_D is being</span>
00295 <span class="comment">   sensitised from input to output, or stopped.</span>
00296 <span class="comment"></span>
00297 <span class="comment">   If there is an X in the input, it is too early to tell, return is trivally true.</span>
00298 <span class="comment">   If there is no D/_D in the input, the return is trivially true.</span>
00299 <span class="comment">   If there is a D/_D in the input, the result is true only if the result is D/_D.</span>
00300 <span class="comment"> */</span>
00301   ContainerType::iterator target=std::find_if(vDLogic.begin(),vDLogic.end(),<a class="code" href="structisXTypeFunctor.html">isXTypeFunctor</a>());
00302   <span class="keywordtype">bool</span> bReturn=<span class="keyword">false</span>;
00303   <span class="keywordflow">if</span>(vDLogic.end()==target){ <span class="comment">// container has no Xs</span>
00304     target=std::find_if(vDLogic.begin(),vDLogic.end(),<a class="code" href="structisDTypeFunctor.html">isDTypeFunctor</a>());
00305     <span class="keywordflow">if</span>(vDLogic.end()!=target){ <span class="comment">// container contains a D/_D</span>
00306       bReturn=(<a class="code" href="classDLogic.html#p2">DLogic::D</a>==result||<a class="code" href="classDLogic.html#p3">DLogic::_D</a>==result);
00307     }<span class="keywordflow">else</span>{
00308       bReturn=<span class="keyword">true</span>;
00309     }
00310   }<span class="keywordflow">else</span>{
00311     bReturn=<span class="keyword">true</span>;
00312   }
00313   <span class="keywordflow">return</span> bReturn;
<a name="l00314"></a><a class="code" href="atpg_8hpp.html#a6">00314</a> };
00315 <span class="keywordtype">bool</span> <a class="code" href="atpg_8hpp.html#a6">OutputConsistent</a>(<a class="code" href="classDLogic.html">DLogic</a> sA, <a class="code" href="classDLogic.html">DLogic</a> sB){
00316 <span class="comment">/* Verifies that the sA can replace sB without violating consistency rules.</span>
00317 <span class="comment">   where sA == signal evaluated for update</span>
00318 <span class="comment">         sB == signal already on output edges</span>
00319 <span class="comment"></span>
00320 <span class="comment">   For example, if sA=1 and sB=0, there is inconsistency.</span>
00321 <span class="comment">                if sB=X, any value of sA is fine</span>
00322 <span class="comment">                if sB=D or _D, we are seeing a stuck-at-fault, so skip as well</span>
00323 <span class="comment"> */</span>
00324     <span class="keywordflow">if</span>(<a class="code" href="classDLogic.html#p1">DLogic::ONE</a>==sB || <a class="code" href="classDLogic.html#p0">DLogic::ZERO</a>==sB ){
00325       <span class="keywordflow">return</span> (sA==sB);
00326     }<span class="keywordflow">else</span>{
00327       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00328     }
00329 };
<a name="l00330"></a><a class="code" href="atpg_8hpp.html#a7">00330</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Vertex,<span class="keyword">class</span> GraphType&gt; 
00331 <a class="code" href="classDLogic.html">DLogic</a> <a class="code" href="atpg_8hpp.html#a7">EvaluateOutputs</a>(Vertex&amp; v, GraphType&amp; g){
00332   <span class="comment">/* The functionality can be described as follows :</span>
00333 <span class="comment">     RealSignals, R=={ONE,ZERO,D,_D}</span>
00334 <span class="comment">     Since the vertex has 0 inputs, we are talking about ensuring that all</span>
00335 <span class="comment">     out_edges have the same signal value. This can then be used to</span>
00336 <span class="comment">     set the remaining out_edges</span>
00337 <span class="comment">     Set of out_edges | Evaluated result</span>
00338 <span class="comment">     -----------------|-----------------</span>
00339 <span class="comment">     R,X,X,X          |  R</span>
00340 <span class="comment">     R,R,X,X          |  R</span>
00341 <span class="comment">     R1,R2,X,X        |  assert error ( R1 != R2 )</span>
00342 <span class="comment">     X,X,X,X          |  X</span>
00343 <span class="comment"></span>
00344 <span class="comment">     By convention, </span>
00345 <span class="comment">     D==good/bad==0/1 and _D==1/0</span>
00346 <span class="comment">     Should _D and 1 be considered compatible?</span>
00347 <span class="comment">  */</span> 
00348   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::vertex_attribute_t&gt;::type VertexAttrMapType;
00349   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::edge_attribute_t&gt;::type EdgeAttrMapType;
00350   <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::out_edge_iterator OutEdgeIteratorType;
00351   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"EvaluateOutputs"</span>);
00352   VertexAttrMapType vMap=boost::get(boost::vertex_attribute,g);
00353   EdgeAttrMapType eMap=boost::get(boost::edge_attribute,g);
00354   string VertexLabel=vMap[v][<span class="stringliteral">"label"</span>];
00355   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"vertex label=="</span>,VertexLabel);
00356   OutEdgeIteratorType startEI,endEI;
00357   set&lt;string&gt; RealSignalSet;
00358   <span class="keywordflow">for</span>(  tie(startEI,endEI)=out_edges(v,g);startEI!=endEI;++startEI){
00359     string&amp; signal=eMap[*startEI][<span class="stringliteral">"label"</span>];
00360     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"signal=="</span>,signal);
00361     <span class="keywordflow">if</span>(<span class="stringliteral">"X"</span>!=signal){
00362       RealSignalSet.insert(signal);
00363     }<span class="comment">//if</span>
00364   }<span class="comment">//for</span>
00365   string sResult=<span class="stringliteral">"X"</span>;
00366   <span class="keywordflow">switch</span>(RealSignalSet.size()){
00367   <span class="keywordflow">case</span> 0: <span class="comment">// bec no driving signal found</span>
00368     <span class="keywordflow">break</span>;
00369   <span class="keywordflow">case</span> 1: <span class="comment">// one consistent driving signal found</span>
00370     sResult=*(RealSignalSet.begin()); 
00371     <span class="keywordflow">break</span>;
00372   <span class="keywordflow">default</span> : <span class="comment">// more than one incompatible driving signal</span>
00373     cout &lt;&lt; <span class="stringliteral">"Error! More than one incompatible signal found on out_edges of "</span> &lt;&lt; VertexLabel &lt;&lt; <span class="stringliteral">"\n"</span>;
00374     <span class="keywordflow">break</span>;
00375   }<span class="comment">//switch</span>
00376   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"sResult=="</span>,sResult);
00377   <span class="keywordflow">return</span> <a class="code" href="classDLogic.html">DLogic</a>(sResult);
<a name="l00378"></a><a class="code" href="atpg_8hpp.html#a8">00378</a> };
00379 <a class="code" href="classDLogic.html">DLogic</a> <a class="code" href="atpg_8hpp.html#a8">EvaluateSingleInput</a>(<span class="keyword">const</span> string&amp; func,<span class="keyword">const</span> string&amp; input){
00380   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"EvaluateSingleInput"</span>);
00381   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"func="</span>,func);
00382   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"input="</span>,input);
00383 
00384   <a class="code" href="classDLogic.html">DLogic</a> result(input);
00385 
00386   <span class="keywordflow">if</span>(<span class="stringliteral">"inv"</span>==func || <span class="stringliteral">"not"</span>==func){
00387     result = (! result);
00388   }
00389   <span class="comment">// D.Dbg("1","result==",result.GetString());</span>
00390     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"result=="</span>,result);
00391   <span class="keywordflow">return</span> result;
<a name="l00392"></a><a class="code" href="atpg_8hpp.html#a9">00392</a> };
00393 <a class="code" href="classDLogic.html">DLogic</a> <a class="code" href="atpg_8hpp.html#a9">EvaluateMultipleInputs</a>(<span class="keyword">const</span> string&amp; func,vector&lt;DLogic&gt;&amp; v){
00394   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"EvaluateMultipleInputs"</span>);
00395   <span class="keyword">static</span> <a class="code" href="structDLogicAndFunctor.html">DLogicAndFunctor&lt;DLogic&gt;</a> DLogicAnd;
00396   <span class="keyword">static</span> <a class="code" href="structDLogicOrFunctor.html">DLogicOrFunctor&lt;DLogic&gt;</a> DLogicOr;
00397   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"func="</span>,func);
00398   ostringstream outputString;
00399   std::copy(v.begin(),v.end(),ostream_iterator&lt;DLogic&gt;(outputString,<span class="stringliteral">","</span>));
00400   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"inputs=="</span>,outputString.str());
00401 
00402   <a class="code" href="classDLogic.html">DLogic</a> result=<a class="code" href="classDLogic.html#p4">DLogic::X</a>;
00403   <span class="keywordflow">if</span>(<span class="stringliteral">"nand"</span>==func){
00404      result= ! std::accumulate(v.begin(),v.end(),<a class="code" href="classDLogic.html#p1">DLogic::ONE</a>,DLogicAnd);
00405   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<span class="stringliteral">"nor"</span>==func){
00406      result= ! std::accumulate(v.begin(),v.end(),<a class="code" href="classDLogic.html#p0">DLogic::ZERO</a>,DLogicOr);
00407   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<span class="stringliteral">"and"</span>==func){
00408      result=std::accumulate(v.begin(),v.end(),<a class="code" href="classDLogic.html#p1">DLogic::ONE</a>,DLogicAnd);
00409   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<span class="stringliteral">"or"</span>==func){
00410      result=std::accumulate(v.begin(),v.end(),<a class="code" href="classDLogic.html#p0">DLogic::ZERO</a>,DLogicOr);
00411   }
00412   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"result=="</span>,result.<a class="code" href="classDLogic.html#a18">GetString</a>());
00413   <span class="keywordflow">return</span> result;
00414 };
<a name="l00415"></a><a class="code" href="atpg_8hpp.html#a10">00415</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> VertexType,<span class="keyword">class</span> GraphType&gt;
00416 <span class="keywordtype">void</span> <a class="code" href="atpg_8hpp.html#a10">setOutputEdges</a>(VertexType&amp; v, GraphType&amp; g, <a class="code" href="classDLogic.html">DLogic</a> d){
00417   <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::out_edge_iterator OutEdgeIteratorType;
00418   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::edge_attribute_t&gt;::type EdgeAttrMapType;
00419   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"setOutputEdges"</span>);
00420   EdgeAttrMapType eMap=boost::get(edge_attribute,g);
00421   OutEdgeIteratorType startEI,endEI;
00422   string signal=d.<a class="code" href="classDLogic.html#a18">GetString</a>();
00423   <span class="keywordflow">for</span>(  tie(startEI,endEI)=out_edges(v,g);startEI!=endEI;++startEI){
00424     string&amp; edgeLabel=eMap[*startEI][<span class="stringliteral">"label"</span>];
00425     <span class="keywordflow">if</span>(<span class="stringliteral">"X"</span>==edgeLabel){
00426       eMap[*startEI][<span class="stringliteral">"label"</span>]=signal;
00427     }<span class="keywordflow">else</span>{
00428       cout &lt;&lt; <span class="stringliteral">"Warning! Output edge should be X\n"</span>;
00429     }
00430   }
00431 };
00432 <span class="comment">// ------------------------------------------------------------</span>
00433 <span class="comment">// class XEdgeVisitor</span>
00434 <span class="comment">// ------------------------------------------------------------</span>
<a name="l00435"></a><a class="code" href="classXEdgeVisitor.html">00435</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> GraphType&gt;
00436 <span class="keyword">class </span><a class="code" href="classXEdgeVisitor.html">XEdgeVisitor</a> : <span class="keyword">public</span> boost::default_dfs_visitor{
00437 <span class="comment">/* Set an un-initialized edge to "X"</span>
00438 <span class="comment">   Combined with DFS traversal, sets all un-initialized edges to "X"</span>
00439 <span class="comment">   NB - compiler defaults of destructor, copy constructor sufficient</span>
00440 <span class="comment"> */</span>
<a name="l00441"></a><a class="code" href="classXEdgeVisitor.html#s0">00441</a> <span class="keyword">public</span> :
<a name="l00442"></a><a class="code" href="classXEdgeVisitor.html#s1">00442</a>   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::vertex_attribute_t&gt;::type <a class="code" href="classXEdgeVisitor.html#s0">VertexAttrMapType</a>;
<a name="l00443"></a><a class="code" href="classXEdgeVisitor.html#a0">00443</a>   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::edge_attribute_t&gt;::type <a class="code" href="classXEdgeVisitor.html#s1">EdgeAttrMapType</a>;
<a name="l00444"></a><a class="code" href="classXEdgeVisitor.html#a1">00444</a>   <a class="code" href="classXEdgeVisitor.html#a0">XEdgeVisitor</a>(GraphType&amp; g){ _EdgeAttrMap=boost::get(edge_attribute,g); }
00445   <span class="keyword">template</span> &lt;<span class="keyword">class</span> Edge, <span class="keyword">class</span> GraphType&gt; <span class="keywordtype">void</span> <a class="code" href="classXEdgeVisitor.html#a1">examine_edge</a>(Edge e, <span class="keyword">const</span> GraphType &amp;){
00446     <span class="keywordflow">if</span>(<span class="stringliteral">""</span>==_EdgeAttrMap[e][<span class="stringliteral">"label"</span>])
00447       _EdgeAttrMap[e][<span class="stringliteral">"label"</span>]=<span class="stringliteral">"X"</span>;
00448   }
00449 <span class="keyword">private</span>:
00450   <a class="code" href="classXEdgeVisitor.html#a0">XEdgeVisitor</a>();
00451   <a class="code" href="classXEdgeVisitor.html">XEdgeVisitor</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classXEdgeVisitor.html">XEdgeVisitor</a>&amp;);
00452   <a class="code" href="classXEdgeVisitor.html#s1">EdgeAttrMapType</a> _EdgeAttrMap;
00453 };
00454 <span class="comment">// ------------------------------------------------------------</span>
00455 <span class="comment">// class GetSignalFunctor</span>
00456 <span class="comment">// ------------------------------------------------------------</span>
<a name="l00457"></a><a class="code" href="classGetSignalFunctor.html">00457</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> GraphType&gt;
00458 <span class="keyword">class </span><a class="code" href="classGetSignalFunctor.html">GetSignalFunctor</a> : <span class="keyword">public</span> unary_function&lt;boost::graph_traits&lt;GraphType&gt;::edge_descriptor,DLogic&gt;{
00459 <span class="comment">/* functor to return signal value of an edge</span>
00460 <span class="comment">   NB - compiler defaults of desctructor, copy constructor sufficient</span>
00461 <span class="comment"> */</span>
<a name="l00462"></a><a class="code" href="classGetSignalFunctor.html#s0">00462</a> <span class="keyword">public</span>:
<a name="l00463"></a><a class="code" href="classGetSignalFunctor.html#s1">00463</a>   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::edge_attribute_t&gt;::type <a class="code" href="classGetSignalFunctor.html#s0">EdgeAttrMapType</a>;
<a name="l00464"></a><a class="code" href="classGetSignalFunctor.html#a0">00464</a>   <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::edge_descriptor <a class="code" href="classGetSignalFunctor.html#s1">EdgeType</a>;
<a name="l00465"></a><a class="code" href="classGetSignalFunctor.html#a1">00465</a>   <a class="code" href="classGetSignalFunctor.html#a0">GetSignalFunctor</a>(GraphType&amp; g){ _E=boost::get(edge_attribute,g);};
00466   <a class="code" href="classDLogic.html">DLogic</a> <a class="code" href="classGetSignalFunctor.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="classGetSignalFunctor.html#s1">EdgeType</a>&amp; e)<span class="keyword"> const </span>{
00467     string&amp; signal=_E[e][<span class="stringliteral">"label"</span>];
00468     <span class="keywordflow">return</span> <a class="code" href="classDLogic.html">DLogic</a>(signal);
00469   };
00470 <span class="keyword">private</span>:
00471   <a class="code" href="classGetSignalFunctor.html#a0">GetSignalFunctor</a>();
00472   <a class="code" href="classGetSignalFunctor.html">GetSignalFunctor</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classGetSignalFunctor.html">GetSignalFunctor</a>&amp;);
00473   <a class="code" href="classGetSignalFunctor.html#s0">EdgeAttrMapType</a> _E;
00474 };
00475 <span class="comment">// ------------------------------------------------------------</span>
00476 <span class="comment">// class BacktraceVisitor</span>
00477 <span class="comment">// ------------------------------------------------------------</span>
<a name="l00478"></a><a class="code" href="classBacktraceVisitor.html">00478</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> GraphType&gt;
00479 <span class="keyword">class </span><a class="code" href="classBacktraceVisitor.html">BacktraceVisitor</a> : <span class="keyword">public</span> boost::default_dfs_visitor{
00480 <span class="comment">/* Given a vertex in the DFrontier, we traceback until we find </span>
00481 <span class="comment">   input nodes. These are kept in a container of unique vertices,</span>
00482 <span class="comment">   actually SetVertexSignalPair.</span>
00483 <span class="comment">   Q : How do we know whether the input nodes have already been visited?</span>
00484 <span class="comment">       There are no Xs on the input node.</span>
00485 <span class="comment">   NB - compiler defaults of desctructor, copy constructor sufficient</span>
00486 <span class="comment">*/</span>
<a name="l00487"></a><a class="code" href="classBacktraceVisitor.html#s0">00487</a> <span class="keyword">public</span>:
<a name="l00488"></a><a class="code" href="classBacktraceVisitor.html#s1">00488</a>   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::vertex_attribute_t&gt;::const_type <a class="code" href="classBacktraceVisitor.html#s0">ConstVertexAttrMapType</a>;
<a name="l00489"></a><a class="code" href="classBacktraceVisitor.html#s2">00489</a>   <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::edge_attribute_t&gt;::type <a class="code" href="classBacktraceVisitor.html#s1">EdgeAttrMapType</a>;
<a name="l00490"></a><a class="code" href="classBacktraceVisitor.html#s3">00490</a>   <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::in_edge_iterator <a class="code" href="classBacktraceVisitor.html#s2">InEdgeIteratorType</a>;
<a name="l00491"></a><a class="code" href="classBacktraceVisitor.html#s4">00491</a>   <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::out_edge_iterator <a class="code" href="classBacktraceVisitor.html#s3">OutEdgeIteratorType</a>;
<a name="l00492"></a><a class="code" href="classBacktraceVisitor.html#s5">00492</a>   <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::vertex_descriptor <a class="code" href="classBacktraceVisitor.html#s4">VertexType</a>;
00493   <span class="keyword">typedef</span> set&lt;VertexSignalPair&lt;VertexType&gt; &gt; <a class="code" href="classBacktraceVisitor.html#s5">SetVertexSignalPairType</a>;
<a name="l00494"></a><a class="code" href="classBacktraceVisitor.html#a0">00494</a> 
00495   <a class="code" href="classBacktraceVisitor.html#a0">BacktraceVisitor</a>(<span class="keyword">const</span> GraphType&amp; g,<a class="code" href="classBacktraceVisitor.html#s1">EdgeAttrMapType</a>&amp; eM,<a class="code" href="classBacktraceVisitor.html#s5">SetVertexSignalPairType</a>&amp; setVS) : _EdgeAttrMap(eM), _SetVS(setVS){
00496   <span class="comment">/* BacktraceVisitor is used with GraphType==&lt;reverse_graph&lt;G&gt;&gt;, so the GraphType edge attr map has to be passed in */</span>
<a name="l00497"></a><a class="code" href="classBacktraceVisitor.html#a1">00497</a>   }
00498   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Vertex,<span class="keyword">class</span> GraphType&gt; <span class="keywordtype">bool</span> <a class="code" href="classBacktraceVisitor.html#a1">HasXs</a>(Vertex v,<span class="keyword">const</span> GraphType&amp; g){
00499     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"HasXs"</span>);
00500     string VertexLabel=boost::get(boost::vertex_attribute,g,v)[<span class="stringliteral">"label"</span>];
00501     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"vertex label=="</span>,VertexLabel);
00502 
00503     <a class="code" href="classBacktraceVisitor.html#s2">InEdgeIteratorType</a> startEI,endEI;
00504     <span class="keywordtype">bool</span> bReturn=<span class="keyword">false</span>;
00505     <span class="keywordflow">for</span>(tie(startEI,endEI)=in_edges(v,g);startEI!=endEI;++startEI){
00506       string&amp; edgeLabel=_EdgeAttrMap[*startEI][<span class="stringliteral">"label"</span>];
00507       D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"edgeLabel=="</span>,edgeLabel);       
00508       <span class="keywordflow">if</span>(<span class="stringliteral">"X"</span>==edgeLabel){
00509         bReturn=<span class="keyword">true</span>;
00510         <span class="keywordflow">break</span>;
00511       }
00512      }
00513     <span class="keywordflow">return</span> bReturn;
<a name="l00514"></a><a class="code" href="classBacktraceVisitor.html#a2">00514</a>   }
00515   <span class="keyword">template</span> &lt;<span class="keyword">class</span> Vertex, <span class="keyword">class</span> GraphType&gt; <a class="code" href="classDLogic.html">DLogic</a> <a class="code" href="classBacktraceVisitor.html#a2">suggestEnablingSignal</a>(Vertex v, <span class="keyword">const</span> GraphType &amp; g){
00516     <span class="comment">/* Looks at source vertices of all incoming edges and collect</span>
00517 <span class="comment">       their func values. Return enabling signal, based on func values if</span>
00518 <span class="comment">       NAND,NOR,AND and OR found. Otherwise, no simple algorithm exists, so we</span>
00519 <span class="comment">       return DLogic::ONE</span>
00520 <span class="comment">       Refactor this function if more models have to be supported.</span>
00521 <span class="comment">    */</span>
00522     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"getEnablingSignal"</span>);
00523     set&lt;string&gt; setFunc;
00524     <span class="comment">// process source vertices, putting func in set</span>
00525     <a class="code" href="classBacktraceVisitor.html#s2">InEdgeIteratorType</a> startEI,endEI;
00526     Vertex vSource;
00527     <span class="keywordflow">for</span>(tie(startEI,endEI)=in_edges(v,g);startEI!=endEI;++startEI){
00528       vSource=source(*startEI,g);
00529       <a class="code" href="classNodeHelper.html">NodeHelper</a> hSource(boost::get(vertex_attribute,g,vSource)[<span class="stringliteral">"label"</span>]);
00530       setFunc.insert(hSource.<a class="code" href="classNodeHelper.html#a4">getFunc</a>());
00531     }<span class="comment">//for</span>
00532 
00533     <a class="code" href="classDLogic.html">DLogic</a> dResult=<a class="code" href="classDLogic.html#p1">DLogic::ONE</a>; <span class="comment">// default</span>
00534     string&amp; sFunc=const_cast&lt;string&amp;&gt;(*(setFunc.begin()));
00535     <span class="keywordflow">switch</span>(setFunc.size()) {
00536     <span class="keywordflow">case</span> 0: 
00537       cout &lt;&lt; <span class="stringliteral">"Warning: vertex drives no function model.\n"</span>;
00538       <span class="keywordflow">break</span>;
00539     <span class="keywordflow">case</span> 1:
00540       <span class="keywordflow">if</span>(<span class="stringliteral">"nand"</span>==sFunc || <span class="stringliteral">"and"</span>==sFunc){
00541         dResult=<a class="code" href="classDLogic.html#p1">DLogic::ONE</a>;
00542       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<span class="stringliteral">"nor"</span>==sFunc || <span class="stringliteral">"or"</span>==sFunc){
00543         dResult=<a class="code" href="classDLogic.html#p0">DLogic::ZERO</a>;
00544       }
00545       <span class="keywordflow">break</span>;
00546     <span class="keywordflow">default</span>:
00547       cout &lt;&lt; <span class="stringliteral">"Warning: vertex drives multiple function models. Using default enabling signal.\n"</span>;
00548       <span class="keywordflow">break</span>;
00549     }<span class="comment">//switch</span>
00550     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"dResult=="</span>,dResult.<a class="code" href="classDLogic.html#a18">GetString</a>());
00551     <span class="keywordflow">return</span> dResult;
<a name="l00552"></a><a class="code" href="classBacktraceVisitor.html#a3">00552</a>   }
00553   <span class="keyword">template</span> &lt;<span class="keyword">class</span> Vertex, <span class="keyword">class</span> GraphType&gt; <span class="keywordtype">void</span> <a class="code" href="classBacktraceVisitor.html#a3">discover_vertex</a>(Vertex v, <span class="keyword">const</span> GraphType &amp; g){
00554     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"discover_vertex"</span>);
00555     string VertexLabel=boost::get(boost::vertex_attribute,g,v)[<span class="stringliteral">"label"</span>];
00556     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"vertex label=="</span>,VertexLabel);
00557     <a class="code" href="classNodeHelper.html">NodeHelper</a> VertexHelper(VertexLabel);
00558     <span class="keyword">const</span> string&amp; VertexFunc=VertexHelper.<a class="code" href="classNodeHelper.html#a4">getFunc</a>();
00559     <span class="keywordflow">if</span>(<span class="stringliteral">"in"</span>==VertexFunc){
00560       <span class="keywordflow">if</span>(<span class="keyword">true</span>==<a class="code" href="classBacktraceVisitor.html#a1">HasXs</a>(v,g)){ <span class="comment">// cannot tweak here</span>
00561         <a class="code" href="classDLogic.html">DLogic</a> driveSignal=<a class="code" href="classBacktraceVisitor.html#a2">suggestEnablingSignal</a>(v,g);
00562         _SetVS.insert(<a class="code" href="classVertexSignalPair.html">VertexSignalPair&lt;Vertex&gt;</a>(v,driveSignal));
00563       }
00564     }<span class="comment">//if input vertices</span>
00565   }
00566 <span class="keyword">private</span>:
00567   <a class="code" href="classBacktraceVisitor.html#a0">BacktraceVisitor</a>();
00568   <a class="code" href="classBacktraceVisitor.html">BacktraceVisitor</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classBacktraceVisitor.html">BacktraceVisitor</a>&amp;);
00569   <a class="code" href="classBacktraceVisitor.html#s1">EdgeAttrMapType</a>&amp; _EdgeAttrMap;
00570   <a class="code" href="classBacktraceVisitor.html#s5">SetVertexSignalPairType</a>&amp; _SetVS; <span class="comment">// set of vertex-signal</span>
00571 };
00572 <span class="comment">// ------------------------------------------------------------</span>
00573 <span class="comment">// class NodeHelper</span>
<a name="l00574"></a><a class="code" href="classNodeHelper.html">00574</a> <span class="comment">// ------------------------------------------------------------</span>
00575 <span class="keyword">class </span><a class="code" href="classNodeHelper.html">NodeHelper</a>{
00576   <span class="comment">/* Class implements format policy of Vertex label</span>
00577 <span class="comment">     label == name:func, with default func==noop</span>
00578 <span class="comment">     using defaults for constructor and copy constructor</span>
00579 <span class="comment">     NB - compiler defaults of destructor, copy constructor, operator= sufficient</span>
00580 <span class="comment">   */</span>
<a name="l00581"></a><a class="code" href="classNodeHelper.html#a0">00581</a> <span class="keyword">public</span>:
00582   <a class="code" href="classNodeHelper.html#a0">NodeHelper</a>(<span class="keyword">const</span> string&amp; label){
00583     string::size_type dotLocation=label.find_first_of(<span class="stringliteral">":"</span>);
00584     <span class="keywordflow">if</span>(string::npos!=dotLocation){
00585       <a class="code" href="classNodeHelper.html#a1">setName</a>(label.substr(1,dotLocation));
00586       <a class="code" href="classNodeHelper.html#a2">setFunc</a>(label.substr(dotLocation+1));
00587     }<span class="keywordflow">else</span>{
00588       <a class="code" href="classNodeHelper.html#a1">setName</a>(label);
00589       <a class="code" href="classNodeHelper.html#a2">setFunc</a>(<span class="stringliteral">"noop"</span>);
00590     }
<a name="l00591"></a><a class="code" href="classNodeHelper.html#a1">00591</a>   }
<a name="l00592"></a><a class="code" href="classNodeHelper.html#a2">00592</a>   <span class="keywordtype">void</span> <a class="code" href="classNodeHelper.html#a1">setName</a>(<span class="keyword">const</span> string&amp; name){ _name=name; }
<a name="l00593"></a><a class="code" href="classNodeHelper.html#a3">00593</a>   <span class="keywordtype">void</span> <a class="code" href="classNodeHelper.html#a2">setFunc</a>(<span class="keyword">const</span> string&amp; func){ _func=func; }
<a name="l00594"></a><a class="code" href="classNodeHelper.html#a4">00594</a>   <span class="keyword">const</span> string&amp; <a class="code" href="classNodeHelper.html#a3">getName</a>(){<span class="keywordflow">return</span> _name;}
00595   <span class="keyword">const</span> string&amp; <a class="code" href="classNodeHelper.html#a4">getFunc</a>(){<span class="keywordflow">return</span> _func;}
00596 <span class="keyword">private</span>:
00597   string _name;
00598   string _func;
00599 };
00600 <span class="comment">// ------------------------------------------------------------</span>
00601 <span class="comment">// class RunGraph</span>
00602 <span class="comment">// ------------------------------------------------------------</span>
<a name="l00603"></a><a class="code" href="classRunGraph.html">00603</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> GraphType&gt;
00604 <span class="keyword">class </span><a class="code" href="classRunGraph.html">RunGraph</a>{
00605 <span class="comment">/* class to implement Podem algorithm</span>
00606 <span class="comment">*/</span>
<a name="l00607"></a><a class="code" href="classRunGraph.html#s0">00607</a> <span class="keyword">public</span>:
<a name="l00608"></a><a class="code" href="classRunGraph.html#s1">00608</a>       <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::vertex_attribute_t&gt;::type <a class="code" href="classRunGraph.html#s0">VertexAttrMapType</a>;
<a name="l00609"></a><a class="code" href="classRunGraph.html#s2">00609</a>           <span class="keyword">typedef</span> boost::property_map&lt;GraphType,boost::edge_attribute_t&gt;::type <a class="code" href="classRunGraph.html#s1">EdgeAttrMapType</a>;
<a name="l00610"></a><a class="code" href="classRunGraph.html#s3">00610</a>       <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::vertex_descriptor <a class="code" href="classRunGraph.html#s2">VertexType</a>;
<a name="l00611"></a><a class="code" href="classRunGraph.html#s4">00611</a>       <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::vertex_iterator <a class="code" href="classRunGraph.html#s3">VertexIteratorType</a>;
<a name="l00612"></a><a class="code" href="classRunGraph.html#s5">00612</a>       <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::edge_iterator <a class="code" href="classRunGraph.html#s4">EdgeIteratorType</a>;
<a name="l00613"></a><a class="code" href="classRunGraph.html#s6">00613</a>       <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::in_edge_iterator <a class="code" href="classRunGraph.html#s5">InEdgeIteratorType</a>;
<a name="l00614"></a><a class="code" href="classRunGraph.html#s7">00614</a>       <span class="keyword">typedef</span> boost::graph_traits&lt;GraphType&gt;::out_edge_iterator <a class="code" href="classRunGraph.html#s6">OutEdgeIteratorType</a>;
<a name="l00615"></a><a class="code" href="classRunGraph.html#s8">00615</a>       <span class="keyword">typedef</span> std::deque&lt;VertexType&gt; <a class="code" href="classRunGraph.html#s7">DFrontierType</a>;
<a name="l00616"></a><a class="code" href="classRunGraph.html#s9">00616</a>       <span class="keyword">typedef</span> std::deque&lt;VertexType&gt; <a class="code" href="classRunGraph.html#s8">PropagateContainerType</a>;
00617       <span class="keyword">typedef</span> set&lt;VertexSignalPair&lt;VertexType&gt; &gt; <a class="code" href="classRunGraph.html#s9">SetVertexSignalPairType</a>;
00618       <span class="comment">// Needs boost::               Y                    N                            Y                    N</span>
00619           <a class="code" href="classRunGraph.html#a0">BOOST_STATIC_ASSERT</a>((boost::is_same&lt;GraphType,GraphvizGraph&gt;::value || boost::is_same&lt;GraphType,GraphvizDigraph&gt;::value));
00620       <a class="code" href="classRunGraph.html#a1">RunGraph</a>(<span class="keyword">const</span> string&amp; path);
00621       <a class="code" href="classRunGraph.html#a2">~RunGraph</a>();
00622       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a3">setDebug</a>(<span class="keyword">const</span> string&amp; dString);
00623       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a4">initializeGraph</a>();
00624       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a5">backtraceVertex</a>(<span class="keyword">const</span> <a class="code" href="classRunGraph.html#s2">VertexType</a>&amp; v);
00625       <span class="comment">// propagate code</span>
00626       <span class="keywordtype">bool</span> <a class="code" href="classRunGraph.html#a6">processOutput</a>(<a class="code" href="classRunGraph.html#s2">VertexType</a> v,GraphType&amp; g,<a class="code" href="classRunGraph.html#s8">PropagateContainerType</a>&amp; cv,<a class="code" href="classDLogic.html">DLogic</a> outS,<a class="code" href="classDLogic.html">DLogic</a> currentS);
00627       <a class="code" href="atpg_8hpp.html#a0">tripleBool</a> <a class="code" href="classRunGraph.html#a7">propagateChange</a>(<a class="code" href="classRunGraph.html#s2">VertexType</a> v, GraphType&amp; g,<a class="code" href="classRunGraph.html#s8">PropagateContainerType</a>&amp; cv);
00628       <a class="code" href="atpg_8hpp.html#a0">tripleBool</a> <a class="code" href="classRunGraph.html#a8">propagateVertex</a>(<a class="code" href="classRunGraph.html#s2">VertexType</a> v, <a class="code" href="classDLogic.html">DLogic</a> driveSignal);
00629       <span class="comment">// driver code</span>
00630       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a9">runATPG</a>();
00631       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a10">test</a>(<span class="keyword">const</span> string&amp; startLabel);
<a name="l00632"></a><a class="code" href="classRunGraph.html#a11">00632</a> 
00633       <a class="code" href="classRunGraph.html#s2">VertexType</a> <a class="code" href="classRunGraph.html#a11">endVertex</a>(){ <span class="keywordflow">return</span> *vertices(_g).second; }; <span class="comment">// syntatic sugar for making vertex checks clearer. Q, should keep value or call vertices each time?</span>
00634       <a class="code" href="classRunGraph.html#s2">VertexType</a> <a class="code" href="classRunGraph.html#a12">findVertexWithLabel</a>(<span class="keyword">const</span> string&amp; label);
00635       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a13">writeGraph</a>(<span class="keyword">const</span> string&amp; path);
00636       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a14">seedDFrontier</a>(<a class="code" href="classRunGraph.html#s7">DFrontierType</a>&amp; dF);
00637       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a15">updateDFrontier</a>(<a class="code" href="classRunGraph.html#s7">DFrontierType</a>&amp; dF);
<a name="l00638"></a><a class="code" href="classRunGraph.html#a17">00638</a>       <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a16">printFinishStats</a>(<span class="keywordtype">bool</span> DFrontierEmpty,<span class="keywordtype">bool</span> FirstOutputFound, <span class="keywordtype">bool</span> FirstNonDPassable, <span class="keywordtype">bool</span> FirstInconsistentOutput);
00639       <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classRunGraph.html#a17">getVersion</a>(){ <span class="keywordflow">return</span> <a class="code" href="classRunGraph.html#p0">_Version</a>; };
00640       <span class="keyword">static</span> <span class="keywordtype">char</span>* <a class="code" href="classRunGraph.html#p0">_Version</a>;
00641 <span class="keyword">private</span>:
00642       <a class="code" href="classRunGraph.html#a1">RunGraph</a>();
00643       <a class="code" href="classRunGraph.html#a1">RunGraph</a>(<span class="keyword">const</span> <a class="code" href="classRunGraph.html">RunGraph</a>&amp;);
00644       <a class="code" href="classRunGraph.html">RunGraph</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classRunGraph.html">RunGraph</a>&amp;);
00645       GraphType _g;
00646       <a class="code" href="classRunGraph.html#s0">VertexAttrMapType</a> _v;
00647       <a class="code" href="classRunGraph.html#s1">EdgeAttrMapType</a> _e;
00648       <a class="code" href="classRunGraph.html#s7">DFrontierType</a> _df;
00649       reverse_graph&lt;GraphType&gt;* _pRG;
00650       <a class="code" href="classRunGraph.html#s9">SetVertexSignalPairType</a> _setVS;
00651 };
<a name="l00652"></a><a class="code" href="classRunGraph.html#p0">00652</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00653 <span class="keywordtype">char</span>* <a class="code" href="classRunGraph.html">RunGraph&lt;G&gt;</a>::_Version=<span class="stringliteral">"$Id$"</span>;
<a name="l00654"></a><a class="code" href="classRunGraph.html#a1">00654</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00655 <a class="code" href="classRunGraph.html#a1">RunGraph&lt;G&gt;::RunGraph</a>(<span class="keyword">const</span> string&amp; path){
00656   cout &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; path &lt;&lt; <span class="stringliteral">"\n"</span>;
00657   read_graphviz(path.c_str(),_g);
00658   _v=boost::get(vertex_attribute,_g);
00659   _e=boost::get(edge_attribute,_g);
00660   _df.clear();
00661   _setVS.clear();
00662   _pRG=<span class="keyword">new</span> reverse_graph&lt;G&gt;(_g);
00663 };
<a name="l00664"></a><a class="code" href="classRunGraph.html#a2">00664</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00665 <a class="code" href="classRunGraph.html#a2">RunGraph&lt;G&gt;::~RunGraph</a>(){
00666   <span class="keyword">delete</span> _pRG;
00667 };
<a name="l00668"></a><a class="code" href="classRunGraph.html#a13">00668</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00669 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a13">RunGraph&lt;G&gt;::writeGraph</a>(<span class="keyword">const</span> string&amp; path){
00670   cout &lt;&lt; <span class="stringliteral">"Writing "</span> &lt;&lt; path &lt;&lt; <span class="stringliteral">"\n"</span>;
00671   write_graphviz(path.c_str(),_g);
00672 };
<a name="l00673"></a><a class="code" href="classRunGraph.html#a12">00673</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00674 <a class="code" href="classRunGraph.html">RunGraph&lt;G&gt;</a>::VertexType <a class="code" href="classRunGraph.html#a12">RunGraph&lt;G&gt;::findVertexWithLabel</a>(<span class="keyword">const</span> string&amp; label){
00675    <a class="code" href="classRunGraph.html#s3">VertexIteratorType</a> viStart,viEnd;
00676    <span class="keywordflow">for</span>(tie(viStart,viEnd)=vertices(_g);viStart!=viEnd;++viStart){
00677       <span class="keywordflow">if</span>(label==_v[*viStart][<span class="stringliteral">"label"</span>]){
00678         <span class="keywordflow">return</span> *viStart;
00679       }
00680    }
00681    <span class="keywordflow">return</span> *viEnd;
00682 };
<a name="l00683"></a><a class="code" href="classRunGraph.html#a14">00683</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00684 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a14">RunGraph&lt;G&gt;::seedDFrontier</a>(DFrontierType&amp; dF){
00685 <span class="comment">/* Search graph for edges with D/_D and put their target vertices</span>
00686 <span class="comment">   into DFrontier. Checks before inserting vertices so that DFrontier</span>
00687 <span class="comment">   has no duplicate vertices.</span>
00688 <span class="comment">   Note: Tradeoff performance to search for all faults in graph, so that</span>
00689 <span class="comment">   we can study multiple faults. Alternate implementation could return when</span>
00690 <span class="comment">   first fault found.</span>
00691 <span class="comment">*/</span>
00692    <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"seedDFrontier"</span>);
00693    <a class="code" href="classRunGraph.html#s4">EdgeIteratorType</a> firstEI,lastEI;
00694    <a class="code" href="classRunGraph.html#s2">VertexType</a> vTarget;
00695    <span class="keywordflow">for</span>(tie(firstEI,lastEI)=edges(_g);firstEI!=lastEI;++firstEI){
00696      <span class="keywordflow">if</span>((<span class="stringliteral">"D"</span>==_e[*firstEI][<span class="stringliteral">"label"</span>])||(<span class="stringliteral">"_D"</span>==_e[*firstEI][<span class="stringliteral">"label"</span>])){
00697       vTarget=target(*firstEI,_g);
00698       DFrontierType::iterator iVertexFound=std::find(dF.begin(),dF.end(),vTarget);
00699       <span class="keywordflow">if</span>(dF.end()==iVertexFound){
00700         dF.push_back(vTarget);
00701       }<span class="comment">//if vTarget not in DFrontier</span>
00702      }<span class="comment">//if edge has fault injected</span>
00703    }<span class="comment">//for all edges</span>
00704    <a class="code" href="atpg_8hpp.html#a1">dumpDFrontier</a>(dF,_v);
00705 };
<a name="l00706"></a><a class="code" href="classRunGraph.html#a15">00706</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00707 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a15">RunGraph&lt;G&gt;::updateDFrontier</a>(DFrontierType&amp; dF){
00708 <span class="comment">/* If there are no more undriven inputs of the front element, remove it */</span>
00709   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"updateDFrontier"</span>);
00710   assert(0!=dF.size()); <span class="comment">// function should not be called if DFrontier is empty</span>
00711   <a class="code" href="classRunGraph.html#s5">InEdgeIteratorType</a> firstEI,lastEI;
00712   set&lt;string&gt; InputSignalSet;
00713   <a class="code" href="classRunGraph.html#s2">VertexType</a> vTarget=*(dF.begin());
00714   <span class="keywordflow">for</span>(tie(firstEI,lastEI)=in_edges(vTarget,_g);firstEI!=lastEI;++firstEI){
00715     string&amp; signal=_e[*firstEI][<span class="stringliteral">"label"</span>];
00716     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"signal=="</span>,signal);
00717     <span class="keywordflow">if</span>(<span class="stringliteral">"X"</span>==signal){
00718       InputSignalSet.insert(signal);
00719     }
00720   }<span class="comment">//for all edges</span>
00721   <span class="keywordflow">if</span>(0==InputSignalSet.size()){
00722     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"updateDFrontier: "</span>,<span class="stringliteral">"removing vertex"</span>);
00723     dF.pop_front();
00724   }
00725   <a class="code" href="atpg_8hpp.html#a1">dumpDFrontier</a>(dF,_v);
00726 };
<a name="l00727"></a><a class="code" href="classRunGraph.html#a16">00727</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00728 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a16">RunGraph&lt;G&gt;::printFinishStats</a>(<span class="keywordtype">bool</span> DFrontierEmpty,<span class="keywordtype">bool</span> FirstOutputFound, <span class="keywordtype">bool</span> FirstNonDPassable, <span class="keywordtype">bool</span> FirstInconsistentOutput){
00729   <span class="keywordflow">if</span>(<span class="keyword">true</span>==FirstNonDPassable||<span class="keyword">true</span>==FirstInconsistentOutput){
00730     cout &lt;&lt; <span class="stringliteral">"Bad run\n"</span>;
00731   }<span class="keywordflow">else</span>{
00732     cout &lt;&lt; <span class="stringliteral">"Good run\n"</span>;
00733   }
00734   cout &lt;&lt; boolalpha;
00735   cout &lt;&lt; <span class="stringliteral">"\t1) DFrontier empty :\t"</span> &lt;&lt; DFrontierEmpty &lt;&lt; <span class="stringliteral">"\n"</span>;
00736   cout &lt;&lt; <span class="stringliteral">"\t2) First output found :\t"</span> &lt;&lt; FirstOutputFound &lt;&lt; <span class="stringliteral">"\n"</span>;
00737   cout &lt;&lt; <span class="stringliteral">"\t3) First non D passable found :\t"</span> &lt;&lt; FirstNonDPassable &lt;&lt; <span class="stringliteral">"\n"</span>;
00738   cout &lt;&lt; <span class="stringliteral">"\t4) First inconsistent output found :\t"</span> &lt;&lt; FirstInconsistentOutput &lt;&lt; <span class="stringliteral">"\n"</span>;
00739 };
<a name="l00740"></a><a class="code" href="classRunGraph.html#a3">00740</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00741 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a3">RunGraph&lt;G&gt;::setDebug</a>(<span class="keyword">const</span> string&amp; dString){
00742   <a class="code" href="classDebug.html#d0">Debug::specify</a>(dString.c_str());
00743 };
<a name="l00744"></a><a class="code" href="classRunGraph.html#a4">00744</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00745 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a4">RunGraph&lt;G&gt;::initializeGraph</a>(){
00746   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"initializeGraph"</span>);
00747   <a class="code" href="classXEdgeVisitor.html">XEdgeVisitor&lt;G&gt;</a> initV(_g);
00748   depth_first_search(_g,visitor(initV));
00749   cout &lt;&lt; <span class="stringliteral">"\n"</span>;
00750 };
<a name="l00751"></a><a class="code" href="classRunGraph.html#a5">00751</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00752 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a5">RunGraph&lt;G&gt;::backtraceVertex</a>(<span class="keyword">const</span> VertexType&amp; v){
00753   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"backtraceGraph"</span>);
00754   string&amp; vertexLabel=_v[v][<span class="stringliteral">"label"</span>];
00755   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"vertex label=="</span>,vertexLabel);
00756 
00757   <span class="keyword">typedef</span> std::vector&lt;default_color_type&gt; ColorMapType;
00758   ColorMapType GraphColorMap(num_vertices(_g));
00759   <a class="code" href="classBacktraceVisitor.html">BacktraceVisitor&lt;reverse_graph&lt;G&gt;</a> &gt; backtraceVisitor(_g,_e,_setVS);
00760   depth_first_visit(*_pRG,v,backtraceVisitor,&amp;GraphColorMap[0]);
00761 };
<a name="l00762"></a><a class="code" href="classRunGraph.html#a8">00762</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00763 <a class="code" href="atpg_8hpp.html#a0">tripleBool</a> <a class="code" href="classRunGraph.html#a8">RunGraph&lt;G&gt;::propagateVertex</a>(VertexType v, <a class="code" href="classDLogic.html">DLogic</a> driveSignal){
00764     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"propagateVertex"</span>);
00765     string VertexLabel=_v[v][<span class="stringliteral">"label"</span>];
00766     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"vertex label=="</span>,VertexLabel);
00767     deque&lt;VertexType&gt; cV;
00768     cV.push_back(v);
00769     <a class="code" href="atpg_8hpp.html#a10">setOutputEdges</a>(v,_g,driveSignal);
00770     <a class="code" href="classRunGraph.html#s2">VertexType</a> vOrigin;
00771     <span class="keywordtype">bool</span> bOutputFound=<span class="keyword">false</span>,bInconsistentOutput=<span class="keyword">false</span>,bNonDPassable=<span class="keyword">false</span>;
00772     <span class="keywordflow">while</span>(0!=cV.size()){
00773       ostringstream outputString;
00774       <span class="keywordflow">for</span>(deque&lt;VertexType&gt;::iterator it=cV.begin();it!=cV.end();++it){
00775         outputString &lt;&lt; _v[*it][<span class="stringliteral">"label"</span>]+<span class="stringliteral">","</span>;
00776       }
00777       D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"cV=="</span>,outputString.str());
00778       vOrigin=*cV.begin();
00779       tie(bOutputFound,bInconsistentOutput,bNonDPassable)=<a class="code" href="classRunGraph.html#a7">propagateChange</a>(vOrigin,_g,cV);
00780       cV.pop_front();
00781       <span class="keywordflow">if</span>(bOutputFound||bInconsistentOutput||bNonDPassable) <span class="keywordflow">break</span>;
00782     }
00783     <span class="keywordflow">return</span> <a class="code" href="atpg_8hpp.html#a0">tripleBool</a>(bOutputFound,bInconsistentOutput,bNonDPassable);
00784 };
<a name="l00785"></a><a class="code" href="classRunGraph.html#a6">00785</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00786 <span class="keywordtype">bool</span> <a class="code" href="classRunGraph.html#a6">RunGraph&lt;G&gt;::processOutput</a>(VertexType v,G&amp; g,PropagateContainerType&amp; cv,<a class="code" href="classDLogic.html">DLogic</a> outS,<a class="code" href="classDLogic.html">DLogic</a> currentS){
00787   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"processOutput"</span>);
00788   <span class="keywordtype">bool</span> bInconsistentOutput=<span class="keyword">false</span>;
00789   <span class="keywordflow">if</span>(<span class="keyword">false</span>==<a class="code" href="atpg_8hpp.html#a6">OutputConsistent</a>(outS,currentS)){
00790     bInconsistentOutput=<span class="keyword">true</span>;
00791   }<span class="keywordflow">else</span>{
00792     <span class="keywordflow">if</span>(<a class="code" href="classDLogic.html#p4">DLogic::X</a>!=outS){
00793       <a class="code" href="atpg_8hpp.html#a10">setOutputEdges</a>(v,g,outS);
00794       <a class="code" href="atpg_8hpp.html#a4">putDescendantsInPContainer</a>(v,g,cv);
00795       <span class="keywordflow">if</span>(<a class="code" href="classDLogic.html#p2">DLogic::D</a>==outS||<a class="code" href="classDLogic.html#p3">DLogic::_D</a>==outS) <a class="code" href="atpg_8hpp.html#a3">putDescendantsInDFrontier</a>(v,g,_df);
00796     }
00797   }
00798   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"bInconsistentOutput=="</span>,bInconsistentOutput);
00799   <span class="keywordflow">return</span> bInconsistentOutput;
00800 };
<a name="l00801"></a><a class="code" href="classRunGraph.html#a7">00801</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00802 <a class="code" href="atpg_8hpp.html#a0">tripleBool</a> <a class="code" href="classRunGraph.html#a7">RunGraph&lt;G&gt;::propagateChange</a>(VertexType v, G&amp; g,PropagateContainerType&amp; cv) {
00803     <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"propagateChange"</span>);
00804     string VertexLabel=_v[v][<span class="stringliteral">"label"</span>];
00805     D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"vertex label=="</span>,VertexLabel);
00806     <a class="code" href="classNodeHelper.html">NodeHelper</a> VertexHelper(VertexLabel);
00807     <span class="keyword">const</span> string&amp; VertexFunc=VertexHelper.<a class="code" href="classNodeHelper.html#a4">getFunc</a>();
00808     <a class="code" href="classDLogic.html">DLogic</a> outSignal,currentSignal;
00809 
00810     <span class="keywordtype">bool</span> bOutputFound=<span class="keyword">false</span>;
00811     <span class="keywordtype">bool</span> bInconsistentOutput=<span class="keyword">false</span>;
00812     <span class="keywordtype">bool</span> bNonDPassable=<span class="keyword">false</span>;
00813 
00814     <span class="keywordflow">if</span>(<span class="stringliteral">"noop"</span>!=VertexFunc){
00815       <span class="keywordflow">if</span>(<span class="stringliteral">"out"</span>==VertexFunc){
00816         bOutputFound=<span class="keyword">true</span>;
00817       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<span class="stringliteral">"in"</span>==VertexFunc) {
00818         outSignal=<a class="code" href="atpg_8hpp.html#a7">EvaluateOutputs</a>(v,g);
00819         D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"outSignal=="</span>,outSignal.<a class="code" href="classDLogic.html#a18">GetString</a>());
00820         <a class="code" href="classRunGraph.html#a6">processOutput</a>(v,g,cv,outSignal,<a class="code" href="classDLogic.html#p4">DLogic::X</a>);
00821       }<span class="keywordflow">else</span>{
00822         vector&lt;DLogic&gt; vSignals;
00823         <span class="keywordtype">int</span> totalDegree=degree(v,g); <span class="comment">// Bug in in_degree</span>
00824         <span class="keywordtype">int</span> numOutputs=out_degree(v,g);
00825         <span class="keywordtype">int</span> numInputs=totalDegree-numOutputs;
00826         
00827         <a class="code" href="classRunGraph.html#s5">InEdgeIteratorType</a> startEI,endEI;
00828         <span class="keywordflow">switch</span>(numInputs){
00829         <span class="keywordflow">case</span> 0 :
00830           <span class="keywordflow">break</span>;
00831         <span class="keywordflow">case</span> 1 : <span class="comment">// single input, see Note 1</span>
00832           tie(startEI,endEI)=in_edges(v,g);
00833           outSignal=<a class="code" href="atpg_8hpp.html#a8">EvaluateSingleInput</a>(VertexFunc,_e[*startEI][<span class="stringliteral">"label"</span>]);
00834           currentSignal=<a class="code" href="atpg_8hpp.html#a7">EvaluateOutputs</a>(v,g);
00835           bInconsistentOutput=<a class="code" href="classRunGraph.html#a6">processOutput</a>(v,g,cv,outSignal,currentSignal);
00836           <span class="keywordflow">break</span>;
00837         <span class="keywordflow">default</span> : <span class="comment">// multi-inputs</span>
00838           tie(startEI,endEI)=in_edges(v,g);
00839           <span class="comment">// see podem.oln Note1 : VC6 error if std:: left out of transform</span>
00840           <span class="comment">// see podem.oln Note2 : VC6 error if std:: left out of back_inserter</span>
00841           std::transform(startEI,endEI,std::back_inserter(vSignals),<a class="code" href="classGetSignalFunctor.html">GetSignalFunctor&lt;G&gt;</a>(_g));
00842           outSignal=<a class="code" href="atpg_8hpp.html#a9">EvaluateMultipleInputs</a>(VertexFunc,vSignals);
00843           currentSignal=<a class="code" href="atpg_8hpp.html#a7">EvaluateOutputs</a>(v,g);
00844           <span class="keywordflow">if</span>(<span class="keyword">false</span>==<a class="code" href="atpg_8hpp.html#a5">DPassable</a>(vSignals,outSignal)){
00845             bNonDPassable=<span class="keyword">true</span>;
00846             D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"multi-inputs : "</span>,<span class="stringliteral">"bNonDPassable set to true"</span>);
00847           }
00848           bInconsistentOutput=<a class="code" href="classRunGraph.html#a6">processOutput</a>(v,g,cv,outSignal,currentSignal);
00849           <span class="keywordflow">break</span>;
00850         }<span class="comment">//switch(numInputs)</span>
00851       }
00852     }<span class="comment">//if("noop"!=VertexFunc</span>
00853     <span class="keywordflow">return</span> <a class="code" href="atpg_8hpp.html#a0">tripleBool</a>(bOutputFound,bInconsistentOutput,bNonDPassable);
00854 };
<a name="l00950"></a><a class="code" href="classRunGraph.html#a9">00950</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00951 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a9">RunGraph&lt;G&gt;::runATPG</a>(){
00952   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"runATPG"</span>);
00953 
00954   <span class="keywordtype">bool</span> bFirstOutputFound=<span class="keyword">false</span>,bFirstNonDPassable=<span class="keyword">false</span>,bFirstInconsistentOutput=<span class="keyword">false</span>;
00955   <span class="keywordtype">bool</span> bStopRun=<span class="keyword">false</span>; <span class="comment">// for testing purpose, set to false or remove later</span>
00956   <a class="code" href="classRunGraph.html#s2">VertexType</a> vObjective;
00957   <a class="code" href="classRunGraph.html#a4">initializeGraph</a>();
00958   <a class="code" href="classRunGraph.html#a14">seedDFrontier</a>(_df);
00959   <span class="comment">//  while(!(_df.empty() || bFirstOutputFound || bFirstNonDPassable || bFirstInconsistentOutput || bStopRun)) {</span>
00960   <span class="keywordflow">while</span>(!(_df.empty() || bFirstOutputFound || bStopRun)) {
00961     vObjective=*(_df.begin());
00962     <a class="code" href="classRunGraph.html#a5">backtraceVertex</a>(vObjective);
00963     <a class="code" href="atpg_8hpp.html#a2">dumpSetVS</a>(_setVS,_v);    
00964     <span class="keywordflow">for</span>(SetVertexSignalPairType::iterator it=_setVS.begin();it!=_setVS.end();++it){
00965         tie(bFirstOutputFound,bFirstInconsistentOutput,bFirstNonDPassable)=<a class="code" href="classRunGraph.html#a8">propagateVertex</a>(it-&gt;getVertex(),it-&gt;getSignal());
00966         <span class="keywordflow">if</span>(bFirstOutputFound||bFirstNonDPassable||bFirstInconsistentOutput) <span class="keywordflow">break</span>;
00967     }
00968     _setVS.clear();
00969     <a class="code" href="classRunGraph.html#a15">updateDFrontier</a>(_df); <span class="comment">// remove vObjective if no more undriven inputs</span>
00970     <span class="comment">// writeGraph("debug.dot");</span>
00971     bStopRun=<span class="keyword">false</span>;
00972   };<span class="comment">//while - done with PODEM</span>
00973   <a class="code" href="classRunGraph.html#a16">printFinishStats</a>(_df.empty(),bFirstOutputFound,bFirstNonDPassable,bFirstInconsistentOutput);
00974 };
<a name="l00975"></a><a class="code" href="classRunGraph.html#a10">00975</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00976 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a10">RunGraph&lt;G&gt;::test</a>(<span class="keyword">const</span> string&amp; startLabel){
00977   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"test - new"</span>);
00978 };
00979 <span class="comment">// ------------------------------------------------------------</span>
00980 <span class="comment">// Collection of tests - should not be compiled unless we need it</span>
00981 <span class="comment">// ------------------------------------------------------------</span>
00982 <span class="preprocessor">#if 0</span>
00983 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00984 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a10">RunGraph&lt;G&gt;::test</a>(<span class="keyword">const</span> string&amp; startLabel){
00985   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"test - hasX"</span>);
00986 
00987   <a class="code" href="classBacktraceVisitor.html">BacktraceVisitor&lt;G&gt;</a> forwardVisitor(_g,_v,_e,_setVS);
00988   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"depth_first_search: "</span>,<span class="stringliteral">"forwardVisitor"</span>);
00989   depth_first_search(_g,visitor(forwardVisitor));
00990   cout &lt;&lt;<span class="stringliteral">"\n"</span>;
00991   <a class="code" href="classBacktraceVisitor.html">BacktraceVisitor&lt; reverse_graph&lt;G&gt;</a> &gt; reverseVisitor(*_pRG,_v,_e,_setVS);
00992   D.<a class="code" href="classDebug.html#a2">Dbg</a>(<span class="stringliteral">"1"</span>,<span class="stringliteral">"depth_first_search: "</span>,<span class="stringliteral">"reverseVisitor"</span>);
00993   depth_first_search(*_pRG,visitor(reverseVisitor)); <span class="comment">// reverse graph takes reverseVisitor of type reverse_graph&lt;G&gt;</span>
00994   cout &lt;&lt;<span class="stringliteral">"\n"</span>;
00995 };
00996 <span class="preprocessor">#endif</span>
00997 <span class="preprocessor"></span><span class="preprocessor">#if 0</span>
00998 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
00999 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a10">RunGraph&lt;G&gt;::test</a>(<span class="keyword">const</span> string&amp; startLabel){
01000   <span class="comment">// use zeroinput.dot as input</span>
01001   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"test - reverse_graph"</span>);
01002   cout &lt;&lt; <span class="stringliteral">"No of vertices=="</span> &lt;&lt; num_vertices(*_pRG) &lt;&lt; <span class="stringliteral">"\n"</span>;
01003 <span class="preprocessor">#if defined(REVERSE_PROBLEM)</span>
01004 <span class="preprocessor"></span>  DfsVisitor&lt;G&gt; forwardVisitor(_g);
01005 <span class="preprocessor">#else</span>
01006 <span class="preprocessor"></span>  DfsVisitor&lt;G&gt; forwardVisitor(_g,_v,_e);
01007 <span class="preprocessor">#endif</span>
01008 <span class="preprocessor"></span>  depth_first_search(_g,visitor(forwardVisitor));
01009   cout &lt;&lt;<span class="stringliteral">"\n"</span>;
01010   depth_first_search(*_pRG,visitor(forwardVisitor)); <span class="comment">// reverse graph takes forwardVisitor of type G</span>
01011   cout &lt;&lt;<span class="stringliteral">"\n"</span>;
01012 
01013 <span class="preprocessor">#if defined(REVERSE_PROBLEM)</span>
01014 <span class="preprocessor"></span>  DfsVisitor&lt; reverse_graph&lt;G&gt; &gt; reverseVisitor(*_pRG);
01015 <span class="preprocessor">#else</span>
01016 <span class="preprocessor"></span>  DfsVisitor&lt; reverse_graph&lt;G&gt; &gt; reverseVisitor(*_pRG,_v,_e);
01017 <span class="preprocessor">#endif</span>
01018 <span class="preprocessor"></span>  depth_first_search(*_pRG,visitor(reverseVisitor)); <span class="comment">// reverse graph takes reverseVisitor of type reverse_graph&lt;G&gt;</span>
01019   cout &lt;&lt;<span class="stringliteral">"\n"</span>;
01020 
01021 };
01022 <span class="preprocessor">#endif</span>
01023 <span class="preprocessor"></span><span class="preprocessor">#if 0</span>
01024 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> G&gt;
01025 <span class="keywordtype">void</span> <a class="code" href="classRunGraph.html#a10">RunGraph&lt;G&gt;::test</a>(<span class="keyword">const</span> string&amp; startLabel){
01026   <a class="code" href="classDebug.html">Debug</a> D(<span class="stringliteral">"test - EvaluateMultipleInputs"</span>);
01027   <span class="comment">//  DLogic result=EvaluateSingleInput("not","_D");</span>
01028   <a class="code" href="classDLogic.html">DLogic</a> result;
01029   vector&lt;DLogic&gt; vA;
01030   <span class="keywordflow">for</span>(<a class="code" href="classDLogic.html">DLogic</a> dA=<a class="code" href="classDLogic.html#d0">DLogic::first</a>();dA.<a class="code" href="classDLogic.html#a5">valid</a>();++dA){
01031     <span class="keywordflow">for</span>(<a class="code" href="classDLogic.html">DLogic</a> dB=<a class="code" href="classDLogic.html#d0">DLogic::first</a>();dB.<a class="code" href="classDLogic.html#a5">valid</a>();++dB){
01032       vA.clear();
01033       vA.push_back(dA);
01034       vA.push_back(dB);
01035       result=<a class="code" href="atpg_8hpp.html#a9">EvaluateMultipleInputs</a>(<span class="stringliteral">"nand"</span>,vA);
01036     }
01037   }
01038 };
01039 <span class="preprocessor">#endif// all inactive tests</span>
01040 <span class="preprocessor"></span><span class="comment">// ------------------------------------------------------------</span>
01041 <span class="comment">// Notes</span>
01042 <span class="comment">// ------------------------------------------------------------</span>
01043 <span class="comment">/*</span>
01044 <span class="comment">Note 1 : limitation of single input</span>
01045 <span class="comment">   The current model supported is the NOT, which will allow D/_D to</span>
01046 <span class="comment">   pass always. </span>
01047 <span class="comment">   Thus, DPassable() is not called.</span>
01048 <span class="comment"></span>
01049 <span class="comment">*/</span> 
</pre></div><hr><address style="align: right;"><small>Generated on Mon Jan 20 11:54:25 2003 for ATPG by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
