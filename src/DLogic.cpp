/* Copyright (C) Kwee Heong Tan 2002 - 2003
   Permission is granted to use this code without restriction as
   long as this copyright notice appears in all source files.
*/
//---------------------------------------------------------------------- 
//
//  Filename: $Id: DLogic.cpp,v 1.5 2002/11/21 18:08:36 khtan Exp $
//
//  Description:
//  1) Basic functionality of Class DLogic implementation generated by enum_gen.
//     CUJ Mar 1999 "Enum++ - an enum class code generator" by Art Walker
//  2) Added operator!, operator!! and operator&& functionality
//  3) Cannot use std::logical_or, std::logical_and and std::logical_not
//     bec these return bool. VC6 cannot partially specialize these templates.
//  4) Added DLogic*Functor in DLogic.hpp
//---------------------------------------------------------------------- 
     
#include "DLogic.hpp"
#include <stdlib.h>
     
     
//---------------------------------------------------------------------- 
DLogic::EnumDefStruct  DLogic::m_defArr[] ={
    EnumDefStruct (     0, "ZERO"       ),
    EnumDefStruct (     1, "ONE"        ),
    EnumDefStruct (     2, "D"          ),
    EnumDefStruct (     3, "_D"         ),
    EnumDefStruct (     4, "X"          ),
    EnumDefStruct (     5, "_UNDEFINED" ),
};

const DLogic  DLogic::ZERO       (&m_defArr[0]);
const DLogic  DLogic::ONE        (&m_defArr[1]);
const DLogic  DLogic::D          (&m_defArr[2]);
const DLogic  DLogic::_D         (&m_defArr[3]);
const DLogic  DLogic::X          (&m_defArr[4]);
const DLogic  DLogic::_UNDEFINED (&m_defArr[5]);
// khtan added
const DLogic  DLogic::DLogicAnd[5][5]={ {ZERO,ZERO,ZERO,ZERO,ZERO},
                                        {ZERO,ONE ,D   ,_D  ,X},
                                        {ZERO,D   ,ZERO,ZERO,X},
                                        {ZERO,_D  ,ZERO,_D  ,X},
                                        {ZERO,X   ,X   ,X   ,X},
                                        };
const DLogic  DLogic::DLogicOr[5][5]={  {ZERO,ONE ,D   ,_D  ,X},
                                        {ONE ,ONE ,ONE ,ONE ,ONE},
                                        {D   ,ONE ,D   ,ONE ,X},
                                        {_D  ,ONE ,ONE ,_D  ,X},
                                        {X   ,ONE ,X   ,X   ,X},
                                        };
const DLogic  DLogic::DLogicNot[5]={ONE,ZERO,_D,D,X};

short  DLogic::m_defArrCount = sizeof(DLogic::m_defArr)/sizeof (EnumDefStruct);
     
const char*  DLogic::m_errorMsg = "ERROR: DLogic undefined";
     
//---------------------------------------------------------------------- 
DLogic::DLogic (const string&  name){
    for (int k = 0; k < m_defArrCount - 1; k++){
        if (m_defArr[k].m_name == name){
            m_defPtr = &m_defArr[k];
            return;
        }
    }
    m_defPtr = _UNDEFINED.m_defPtr;
}
     
//---------------------------------------------------------------------- 
DLogic::DLogic (const int  ival ){
    for (int k = 0; k < m_defArrCount - 1; k++){
        if (m_defArr[k].m_value == ival){
            m_defPtr = &m_defArr[k];
            return;
        }
    }
    m_defPtr = _UNDEFINED.m_defPtr;
}
     
//---------------------------------------------------------------------- 
const char* DLogic::GetLabel() const {
    // Note: Do NOT modify this function to "return GetString().c_str()"; 
    // the result of GetString is a temporary which would be deleted upon 
    // return from this function, which means that the pointer returned by 
    // this function would point to a freed memory block!
     
    if (m_defPtr){
        return m_defPtr->m_name.c_str();
    }
    return _UNDEFINED.m_defPtr->m_name.c_str();
}
     
//---------------------------------------------------------------------- 
string DLogic::GetString() const {
    if (m_defPtr){
        return m_defPtr->m_name;
    }
    return _UNDEFINED.m_defPtr->m_name;
}
     
//---------------------------------------------------------------------- 
DLogic DLogic::operator++(){
    if (m_defPtr < _UNDEFINED.m_defPtr){
        m_defPtr++;
    }
    return *this;
}
     
//---------------------------------------------------------------------- 
// Postfix ++
     
DLogic DLogic::operator++(int){
    DLogic  tmp = *this;
    operator++();
    return tmp;
}
     
//---------------------------------------------------------------------- 
DLogic DLogic::operator--(){
    if (m_defPtr > m_defArr){
        m_defPtr--;
    }else{
        m_defPtr = _UNDEFINED.m_defPtr;
    }
    return *this;
}
     
     
//---------------------------------------------------------------------- 
// Postfix --
     
DLogic DLogic::operator--(int) {
    DLogic  tmp = *this;
    operator--();
    return tmp;
}
     
//---------------------------------------------------------------------- 
OSTREAM& operator<< (OSTREAM&  ostr,const DLogic&  objref ){
    ostr << " " << objref.GetString() << " "; 
    return ostr;
}
     
//---------------------------------------------------------------------- 
ISTREAM& operator>> (ISTREAM&  istr,DLogic&  objref ){
    string  name;
    istr >> name;
    objref = DLogic (name);
    return istr;
}
     
//---------------------------------------------------------------------- 
#if 1 // Workaround : to prevent error when comparing with _UNDEFINED
void DLogic::RangeError(){
    cerr << m_errorMsg << endl;
    exit (1);
}
#else
void DLogic::RangeError(){
}
#endif
//---------------------------------------------------------------------- 
